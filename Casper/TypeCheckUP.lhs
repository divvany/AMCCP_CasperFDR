>module TypeCheckUP (typecheckErrors_UP, typecheckWarnings_UP) where

>import Useful
>import Pprint
>import Atoms
>import Messages
>import Types

Perform various checks on the input

>typecheckErrors_UP:: VarTypeList -> ProtDesc -> ProcessList -> ActualAgents -> 
>   ActVarTypeList -> Bool -> String
>typecheckErrors_UP fvts protdesc procs actualagents actvts unboundpar = 
>   let
>       variables_with_unbound_status = 
>           [t | (_,t,s,_) <- actvts, (s == External) || (s == InternalUnknown) || (s == InternalKnown)]
>       vars_without_known = 
>           [unboundvar | (_,_,_,_,unbounds) <- procs, unboundvar <- unbounds, not (hasInternalKnown fvts actvts unboundvar)]
>       vars_without_unknown =
>           [unboundvar | (_,_,_,_,unbounds) <- procs, unboundvar <- unbounds, not (hasInternalUnknown fvts actvts unboundvar)]
>       actualVarsWithUnknownSubtypes = 
>           [v | (v,t,_,sts) <- actvts, not (subset sts (remdups (concat [st | (_,_,st) <- fvts])))]
>       procswithwronggenerators =
>           [pn | (id,pn,args,_,unboundgenerates) <- procs, not (subset unboundgenerates args)]
>   in
>       if unboundpar then
>           -- 1. For each variable that is generated by one of the processes,
>           --    one known actual variable must be defined (e.g. Np)
>           if vars_without_known /= [] then 
>               "The variables " ++ commaConcat vars_without_known ++ 
>               " are generated, but no internal known actual variable were defined.\n"
>           else ""
>           ++
>           -- 2. For every variable that has a subtype a free variable with that
>           --    subtype should be declared
>           if actualVarsWithUnknownSubtypes /= [] then
>               "The variables "++commaConcat actualVarsWithUnknownSubtypes++
>               " have subtypes that are not the subtype of any free variable.\n"
>           else ""
>           ++
>           -- 3. every generated value must be in the argument, too
>           if procswithwronggenerators /= [] then 
>               "The processes "++commaConcat procswithwronggenerators++
>               " have generated variables, that do not appear in the argument list.\n"
>           else ""
>       else
>           -- 4. if unboundpar is false, no variables with an unboundpar status are permitted
>           if variables_with_unbound_status /= [] then 
>               "The variables "++commaConcat variables_with_unbound_status++
>               " have an unbounded parallel status but UnboundParallel=True was "++
>               "not supplied.\n"
>           else ""

>typecheckWarnings_UP:: VarTypeList -> ProtDesc -> ProcessList -> ActualAgents -> 
>   ActVarTypeList -> Bool -> Auths -> Secrets -> String
>typecheckWarnings_UP fvts protdesc procs actualagents actvts unboundpar auths secs = 
>   let
>       externalAgentProcNames = [pn | SeqComp as <- actualagents, (pn,_) <- as]
>       existsNIA = [ds | (_,_,NonInjectiveAgreement ds) <- auths] ++ 
>           [ds | (_,_,TimedNonInjectiveAgreement _ ds) <- auths] /= []
>       existsIA = [ds | (_,_,Agreement ds) <- auths] ++ 
>           [ds | (_,_,TimedAgreement _ ds) <- auths] /= []
>   in
>       if unboundpar then
>           -- 1. All the specifications should be compatible in that the same
>           --    player should need to be externalised in each case.
>           if length (remdups ([b | Sec b _ _ <- secs] ++ [b | (_,b,_) <- auths])) > 1  then
>               "The specifications that were supplied are incompatible; in one file "++
>               "there should be specifications of the type Secret(b,..) and "++
>               "AuthSpec(a,b,...) only.\n"
>           else ""
>           ++
>           -- 2. There should only be one type of external agent.
>           if (length . remdups) externalAgentProcNames > 1 then
>               "There are external agents of several different roles; this is "++
>               "not required for the unbounded parallel mode and may slow down "++
>               "checking.\n"
>           else ""
>           ++
>           -- 3. There should be at least 1 external agent for testing non-injective
>           --    authentication specifications.
>           if length externalAgentProcNames < 1 && existsNIA && not existsIA then
>               "A non-injective authentication specification was supplied but no "++
>               "external agents of the correct type were specifed; the protocol "++
>               "will therefore not be proven correct. See the user manual for more "++
>               "details on the required thresholds.\n"
>           else ""
>           ++
>           -- 4. There should be at least 2 external agents for testing non-injective
>           --    authentication specifications.
>           if length externalAgentProcNames < 2 && existsIA then
>               "An injective authentication specification was supplied but insufficient "++
>               "external agents of the correct type were specified; the protocol "++
>               "will therefore not be proven correct. See the user manual for more "++
>               "details on the required thresholds.\n"
>           else ""
>       else ""


>hasInternalKnown:: VarTypeList -> ActVarTypeList -> TypeName -> Bool
>hasInternalKnown fvts actvts unboundvar = [var | (var,typename,status,_) <- actvts, status == InternalKnown, typename == (findtype_ fvts unboundvar)] /= []

>hasInternalUnknown:: VarTypeList -> ActVarTypeList -> TypeName -> Bool
>hasInternalUnknown fvts actvts unboundvar = [var | (var,typename,status,_) <- actvts, status == InternalUnknown, typename == (findtype_ fvts unboundvar)] /= []

