We export everything

>module Types 

>where

>import Atoms
>import Messages



==========================================================================

>type ProcessName = String
>type Argument = String

>type ProcessInfo = (String, ProcessName, [Argument], [Msg],[VarName])
>type ProcessList = [ProcessInfo]

A ProcessInfo of the form

  ("a", "INITIATOR", ["a"], [Atom "PK", Apply "SK" (Atom "a")],["na"])

corresponds to a line in the input file of the form

  INITIATOR(a) knows PK, SK(a) generates na

The first element of the tuple is the identity by which the agent is known in
the protocol description.

The second element is the name of the process that will be used to represent
the agent.

The third element is the list of variables that the agent initially knows, and
which will be instantiated with values in the #System section.

The fourth element of the tuple represents "knows" functions: functions that
the agent should be taken to know in the protocol description, but which will
not appear in the actual agent process.

The fifth element contains atoms that are generated by the process

=========================================================================
Protocol description

>type MsgNo = String

>data Player = Agent AgentId | Environment
>              deriving (Eq, Ord, Show)

>type AssignmentList = [(VarName, String)]

An element (v,e) represents that an agent should perform the assignment v:= e
before sending the next message.

>type Test = (String, Bool)

The first element gives the string representing the test; the second is a
boolean, saying whether the test uses the variable "now"

>type ProtMsgDesc = (AssignmentList, MsgNo, Player, Player, Msg, Test)
>type ProtDesc = [ProtMsgDesc]

The element (asss, n, Agent A, Agent B, m, t) represents the protocol step

  (asss)
  n. A -> B : m
  [t]


========================================================================
Specifications

>data Secret = Sec AgentId Msg [AgentId] | StrongSec AgentId Msg [AgentId]
>              deriving (Eq, Show)
>type Secrets = [Secret]

>secretVar (Sec _ (Atom v) _) = [v]
>secretVar (StrongSec _ (Atom v) _) = [v]

=========================================================================

Type of authentication specs

>data AuthType = Aliveness | 
>                WeakAgreement |
>                NonInjectiveAgreement [VarName] |
>                Agreement [VarName] | 
>                TimedAliveness Int |
>                TimedWeakAgreement Int |
>                TimedNonInjectiveAgreement Int [VarName] |
>                TimedAgreement Int [VarName]
>                deriving Eq

>instance Show AuthType where
>  showsPrec _ Aliveness _ = "Aliveness"
>  showsPrec _ WeakAgreement _ = "WeakAgreement"
>  showsPrec _ (NonInjectiveAgreement ds) _ = 
>    "NonInjectiveAgreement"++showAuthArgs_ ds
>  showsPrec _ (Agreement ds) _ = "Agreement"++showAuthArgs_ ds
>  showsPrec _ (TimedAliveness t) _ = "TimedAliveness"++show t
>  showsPrec _ (TimedWeakAgreement t) _ = "TimedWeakAgreement"++show t
>  showsPrec _ (TimedNonInjectiveAgreement t ds) _ =
>    "TimedNonInjectiveAgreement"++show t++showAuthArgs_ ds
>  showsPrec _ (TimedAgreement t ds) _ = 
>    "TimedAgreement"++show t++showAuthArgs_ ds

>showAuthArgs_ = concat . map ('_' :)

=============================


>type Auth = (AgentId, AgentId, AuthType)
>type Auths = [Auth]
>type AuthSigInfo = (AgentId, AgentId, [VarName])

>isAliveness Aliveness = True
>isAliveness (TimedAliveness _) = True
>isAliveness _ = False

>isTimedAuth :: AuthType -> Bool
>isTimedAuth (TimedAliveness _) = True
>isTimedAuth (TimedWeakAgreement _) = True
>isTimedAuth (TimedNonInjectiveAgreement _ _) = True
>isTimedAuth (TimedAgreement _ _) = True
>isTimedAuth _ = False

>authArgs (NonInjectiveAgreement ds) = ds
>authArgs (Agreement ds) = ds
>authArgs (TimedNonInjectiveAgreement _ ds) = ds
>authArgs (TimedAgreement _ ds) = ds
>authArgs _ = []

An element of the form (B, A, at) means that B is correctly authenticated to
A, using authentication type at.

=========================================================================
Temporal Logic Specifications

>data Parity = Send | Receive deriving (Eq, Show, Ord)

Represents a bound variable which is either a free variable or a actual variable
in a slot of a free variable

>data BoundVar = 
>   FreeVar VarName                 -- na, nb, etc...
>   | Substitution VarName VarName  -- (freevar, actualvar); AliceNonce for na
>   deriving (Eq, Ord, Show)

>type TLEvent = (AgentId, AgentId, Parity, MsgNo, [BoundVar])

(AgentSpecified, OtherAgent, send/received, MessageId, VariablesBound)

so..

a receives message 2 containing naa, Bob for b would be compiled to:

(a, "", Receive, 2, [FreeVar na,Substitution b Bob])

>data TLFormula =
>   Does TLEvent
>   | And TLFormula TLFormula
>   | Or TLFormula TLFormula
>   | Previously TLFormula
>   | AlwaysIf TLFormula TLFormula
>   deriving (Eq,Show,Ord)

>type TemporalLogicSpec = TLFormula

=========================================================================
Inline functions

>type FunctionRHS = VarName          -- only allow simple inline functions
>data Function = Symbolic VarName | 
>                Defined (VarName, [VarName], FunctionRHS) |
>                Inline (VarName, [VarName], String)
>              deriving (Eq, Show)
>type FunctionList = [Function]

=========================================================================
Actual players in system

>type ActualAgent = (ProcessName, [Argument])

("INITIATOR", ["Alice", "PKa", "SKa", "Sam", "PKs"]) represents the
agent modelled by the process 

INITIATOR(Alice, Na, PKa, SKa, Sam, PKs)

>data SeqActualAgent = Star ActualAgent | SeqComp [ActualAgent]
>                      deriving (Show, Eq)

>type ActualAgents = [SeqActualAgent]
>type WithdrawOption = Bool
>type UnboundParallel = Bool
>data GenerateSystem = 
>   GenerateRepeatSection MsgNo MsgNo       -- (from, to)
>   | GenerateStandard
>   | DontGenerate
>   deriving (Eq, Show)


=========================================================================
Name and initial knowledge of intruder; type of deductions

>type IntruderInitKnowledge = [Msg] 
>type IntruderId = String
>type IntruderProcesses = [ProcessName]

>type Cond = (VarName, TypeName)
>type Deduction = ([Cond], [Msg], Msg)

========================================================================
Equivalences

>type Equivalence = ([Cond], Msg, Msg)

========================================================================
Channel information

>data LineNumbers = All | Some [MsgNo]
>                   deriving (Eq, Show)

>data ChannelComp = Less | Equal | Greater | Incomparable
>                   deriving (Eq, Show)

All LineNumbers means all the messages (this is included for backwards
compatibility and should, of course, be equivalent to listing all
message numbers).  Some[] represents no messages.

isIn checks a message number for membership in a list of message numbers

>isIn _ All = True
>isIn y (Some xs) = foldl (||) False (map (==y) xs)

>type ChannelInfo = (LineNumbers, LineNumbers, LineNumbers)
>type NewChannelInfo = (MsgNo, Channel)
>type Channel = (Integer, Integer, Integer, Integer)
>type SessionInfo = (Integer, Integer, [MsgNo])

SessionInfo describes whether to use a session or stream channel in the
first parameter (0, 1 or 2), and whether to use a normal, injective, or symmetric
channel in the second parameter (0, 1 or 2), and which message numbers form
the session in the third parameter; e.g. (2,1,[3,4]) means messages 3 and 4 are
exchanged over an injective stream channel.

Values in order specify whether channels should be secret, authenticated, and
whether there should be a direct channel between honest participants.

Remember: SAD (secret, authenticated, direct)

========================================================================
Crackable information

>type CrackInfo = (TypeName, Maybe Int)

=========================================================================
Complete input

>type Input = 
>  (VarTypeList, FnTypeList, InverseKeyList, [DataTypeDef], 
>   ProcessList, ProtDesc, Secrets, Auths, [TemporalLogicSpec], ActVarTypeList,
>   InverseKeyList, TimeStampInfo, FunctionList, ActualAgents,  
>   WithdrawOption, UnboundParallel, GenerateSystem, IntruderId, 
>    IntruderInitKnowledge, IntruderProcesses, [CrackInfo], 
>   [Deduction], [TypeName], [Equivalence], ChannelInfo, [NewChannelInfo], [SessionInfo])


>type Inputpd = 
>  (VarTypeList, FnTypeList, InverseKeyList, [DataTypeDef], 
>   ProcessList, ProtDesc, Secrets, Auths)


>type Output = String

The components are:

VarTypeList: The list of free variables used in the protocol
description, with their types;

FnTypeList: List of function names with their types;

InverseKeyList: The list of key inverses for keys used in the protocol
description;

[DataTypeDef] List of definitions of user-defined datatypes

ProcessList: The list of process names and arguments for agents
appearing in the protocol description;

ProtDesc: The protocol description itself;

Secrets: The secret specifications that the protocol is supposed to
meet;

Auths: The authentication specifications that the protocol is supposed
to meet;

ActVarTypeList: The list of actual variables;

InverseKeyList: The list of inverses for actual keys;

TimeStampInfo: Information about how time is used in the system

FunctionList: A list of function definitions;

ActualAgents: The actual agents taking part in the system;

WithdrawOption = Bool: whether withdraw option is specified in the script

UnboundParallel = Bool: wether agents should be internalised to allow unbound
parallal attacks

IntruderId: The identity of the intruder

IntruderInitKnowledge: The initial knowledge of the intruder;

IntruderProcesses = [ProcessName]: list of processes declared as internal
processes

[CrackInfo]: information about crackables

[Deduction]: The list of extra deductions.

guessables :: [TypeName] list of guessable types

[Equivalence]: definition of equivalences

ChannelInfo :: info about whether channels are secret or authenticated

======================================================================
Further types declared:

(For signal events)

>type VarSignalList = [(MsgNo,AgentId,[VarName])]

used for storing the variables required for some spec. by a given
agent in a given message.

(For Data Independence)

>type DiTypeList = [TypeName]  -- dit

>type IntruderProcsId = [AgentId]  -- intruderProcsId

>type FreshVarList = [(MsgNo,(AgentId,[VarName]),(AgentId,[VarName]))]
> -- accumList

