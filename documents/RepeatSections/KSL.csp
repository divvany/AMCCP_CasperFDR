-- CSP script produced using Casper version 2.0

-- -- KSL, slightly simplified.
-- 
-- #Free variables
-- 
-- u : User
-- s : Server
-- as : AuthenticationServer
-- 
-- ts : TimeStamp
-- kab : SessionKey
-- nb, ma : Nonce
-- SKey : Server -> ServerKey
-- UKey : User -> UserKey
-- InverseKeys = (SKey,SKey), (kab,kab), (UKey,UKey)
-- 
-- #Processes
-- 
-- USER(u, ma) knows UKey(u) generates ma
-- SERVER(s, nb) knows SKey(s) generates nb
-- AUTHSERVER(as,kab) knows SKey, UKey generates kab
-- 
-- #Protocol description
-- 
-- 0.   -> u : s, as
-- 1. u -> as : s, ma
-- -- Split message 2 into two
-- 2a. as -> u : {ma, ts, s, kab}{UKey(u)}
-- 2b. as -> u : {ma, ts, kab, u}{SKey(s)} % tkt
-- 
-- -- Start repeated section
-- 4a. u -> s : tkt % {ma, ts, kab, u}{SKey(s)}
-- 5. s -> u : nb, {ma, u}{kab}
-- 6. u -> s : {s, nb}{kab}
-- 
-- #Specification
-- 
-- -- The following specification is used to ensure that the generated system has
-- -- no overlap between InternalKnown and InternalUnknown session keys. If this
-- -- was not specified an overlap would exist resulting in false attacks.
-- -- PASS
-- Secret(u, kab, [s, as])
-- 
-- -- PASS
-- NonInjectiveAgreement(s, u, [kab])
-- -- FAIL
-- Agreement(s, u, [kab])
-- 
-- #Actual variables
-- 
-- TimeStamp = 0 .. 0
-- MaxRunTime = 0
-- Mallory : User
-- 
-- #Functions
-- 
-- symbolic SKey, UKey
-- 
-- #System
-- 
-- GenerateSystemForRepeatSection = 4a to 6
-- 
-- #Intruder Information
-- 
-- Intruder = Mallory
-- IntruderKnowledge = {Mallory, UKey(Mallory)}
-- UnboundParallel = True

-- ************************************************************************
-- *                                Types                                 *
-- ************************************************************************

-- Main datatype, representing all possible messages

datatype Encryption =
  Alice | Bob | Nonce_P | SessionKey_P | kab_S | SessionKey_S | Mallory | 
  Garbage | SKey__.Server | UKey__.User | Timestamp.TS | Sq.Seq(Encryption) | 
  Encrypt.(ALL_KEYS,Seq(Encryption)) | Hash.(HashFunction, Seq(Encryption)) | 
  Xor.(Encryption, Encryption) | Sent.(Encryption, Seq(Encryption)) | 
  AuthTaggedSignals1.AUTH1_M__TaggedSignals1 | 
  AuthTaggedSignals2.AUTH2_M__TaggedSignals2

-- Some indirection to get around FDR parsing bugs with :: in datatype declarations
AUTH1_M__TaggedSignals1 = AUTH1_M::TaggedSignals1
AUTH2_M__TaggedSignals2 = AUTH2_M::TaggedSignals2

-- All keys and hashfunctions in the system

ALL_KEYS :: {Encryption}
ALL_KEYS = Union({SessionKey, ServerKey, UserKey})

ASYMMETRIC_KEYS = {k_, inverse(k_) | k_ <- ALL_KEYS, k_!=inverse(k_)}
HashFunction :: {Encryption}
HashFunction = {}

-- All atoms in the system

ATOM = {Alice, Bob, Nonce_P, SessionKey_P, kab_S, SessionKey_S, Mallory, 
         Garbage}

-- Information about timestamps

now = 0
MinTime = -0
MaxTime = -0
TS = {MinTime .. MaxTime}
MaxRunTime = 0
TimeStamp = {Timestamp.t_ | t_ <- TS}
max(t0_,t1_) = if t0_>t1_ then t0_ else t1_
min(t0_,t1_) = if t0_>t1_ then t1_ else t0_

-- Some standard functions

channel dummyrun_
RUN(X_) = 
  let drun = dummyrun_ -> drun
  within drun[[dummyrun_ <- x_ | x_ <- X_]]

encrypt(m_,k_) = Encrypt.(k_,m_)
decrypt(Encrypt.(k1_,m_),k_) = if k_ == inverse(k1_) then m_ else <Garbage>
decrypt(_,_) = <Garbage>
decryptable(Encrypt.(k1_,m_),k_) = k_ == inverse(k1_) 
decryptable(_,_) = false
nth(ms_,n_) = if n_ == 1 then head(ms_) else nth(tail(ms_), n_ - 1)

map(f_, <>) = <>
map(f_, <x_>^xs_) = <f_(x_)>^map(f_,xs_)

-- Decrement all timestamps by 1
dects(t_) = if t_ > MinTime then t_-1 else t_
updt(Timestamp.t_) = Timestamp.dects(t_)
updt(Sq.es_) = Sq.map(updt,es_)
updt(Encrypt.(k_,es_)) = Encrypt.(k_, map(updt,es_))
updt(Hash.(f_,es_)) = Hash.(f_,map(updt,es_))
updt(Xor.(e1_,e2_)) = Xor.(updt(e1_),updt(e2_))
updt(x_) = x_

-- add Garbage to a set that contains and encryption,
-- hash function application of Vernam encryption

addGarbage_(S_) =
  if S_=={} then {Garbage}
  else Union({S_, {Garbage | Encrypt._ <- S_}, 
             {Garbage | Hash._ <- S_},
             {Garbage | Xor._ <- S_}})

-- Definitions of user supplied functions

SKey(arg_1_) = SKey__.(arg_1_)
UKey(arg_1_) = UKey__.(arg_1_)

-- Inverses of functions

inverse(SessionKey_P) = SessionKey_P
inverse(kab_S) = kab_S
inverse(SessionKey_S) = SessionKey_S
inverse(SKey__.arg_) = SKey__.arg_
inverse(UKey__.arg_) = UKey__.arg_

-- Types in system

User = {Alice, Bob, Mallory}
Server = {Alice}
AuthenticationServer = {Alice}
Nonce = {Nonce_P, Nonce_P}
SessionKey = {SessionKey_P, kab_S, SessionKey_S}
ServerKey = {SKey(arg_1_) | arg_1_ <- Server}
UserKey = {UKey(arg_1_) | arg_1_ <- User}


-- ************************************************************************
-- *                               Messages                               *
-- ************************************************************************

-- Message labels

datatype Labels =
  Msg1 | Msg2a | Msg2b | Msg4a | Msg5 | Msg6 | Env0

MSG_BODY = {ALGEBRA_M::applyRenaming(m_) | (_,m_,_,_) <- SYSTEM_M::INT_MSG_INFO}

-- Type of principals

ALL_PRINCIPALS = Union({User, AuthenticationServer, Server})

INTRUDER = Mallory

HONEST = diff(ALL_PRINCIPALS, {INTRUDER})

-- Channel declarations

INPUT_MSG = SYSTEM_M::INPUT_MSG
OUTPUT_MSG = SYSTEM_M::OUTPUT_MSG
DIRECT_MSG = SYSTEM_M::DIRECT_MSG
ENV_MSG :: {(Labels, Encryption, <Encryption>)}
ENV_MSG = SYSTEM_M::ENV_MSG

channel receive: ALL_PRINCIPALS.ALL_PRINCIPALS.INPUT_MSG
channel send: ALL_PRINCIPALS.ALL_PRINCIPALS.OUTPUT_MSG
channel env : ALL_PRINCIPALS.ENV_MSG
channel error
channel start, close : HONEST.HONEST_ROLE

channel leak : addGarbage_(ALL_SECRETS)
-- Roles of agents

datatype ROLE = USER_role | SERVER_role | AUTHSERVER_role

HONEST_ROLE = ROLE

-- Secrets in the protocol

ALL_SECRETS_0 = SessionKey
ALL_SECRETS = addGarbage_(ALGEBRA_M::applyRenamingToSet(ALL_SECRETS_0))

-- Define type of signals, and declare signal channel

datatype Signal = 
  Claim_Secret.ALL_PRINCIPALS.ALL_SECRETS.Set(ALL_PRINCIPALS) |
  Running1.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.SessionKey |
  Commit1.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.SessionKey |
  RunCom1.ALL_PRINCIPALS.ALL_PRINCIPALS.SessionKey.SessionKey |
  Running2.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.SessionKey |
  Commit2.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.SessionKey |
  RunCom2.ALL_PRINCIPALS.ALL_PRINCIPALS.SessionKey.SessionKey

channel signal : Signal

-- Timing functions

channel tock

TOCKS(n_) = n_>0 & tock -> TOCKS(n_ - 1) [] SKIP
TSKIP = tock -> TSKIP [] SKIP
allowInitTocks(P_) = tock -> allowInitTocks(P_) [] P_
TIMEOUT = tock -> TSKIP
transparent explicate
addTime(P_,n_) = explicate(allowInitTocks((P_ ||| TOCKS(n_)) /\ TIMEOUT))

Fact_1 = 
  Union({
    {Garbage},
    User,
    Server,
    AuthenticationServer,
    TimeStamp,
    SessionKey,
    Nonce,
    UserKey,
    ServerKey,
    {Encrypt.(kab, <ma, u>) |
       kab <- SessionKey, ma <- Nonce, u <- User},
    {Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>) |
       kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User},
    {Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) |
       kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User},
    {Encrypt.(kab, <s, nb>) |
       kab <- SessionKey, nb <- Nonce, s <- Server},
    {Sq.<s, as> |
       as <- AuthenticationServer, s <- Server},
    {Sq.<s, ma> |
       ma <- Nonce, s <- Server},
    {Sq.<nb, Encrypt.(kab, <ma, u>)> |
       kab <- SessionKey, ma <- Nonce, nb <- Nonce, u <- User},
    {Sent.(Sq.<s, ma>, <u, as, s, ma>) |
       as <- AuthenticationServer, ma <- Nonce, s <- Server, u <- User},
    {Sent.(Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>), <as, u, s, ma, Timestamp.ts, kab>) |
       as <- AuthenticationServer, kab <- SessionKey, ma <- Nonce, 
       s <- Server, ts <- TS, u <- User},
    {Sent.(tkt, <as, u, s, ma, Timestamp.ts, kab>) |
       as <- AuthenticationServer, kab <- SessionKey, ma <- Nonce, 
       s <- Server, ts <- TS, u <- User, 
       tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})},
    {Sent.(tkt, <u, s, as, ma, Timestamp.ts, kab, tkt>) |
       as <- AuthenticationServer, kab <- SessionKey, ma <- Nonce, 
       s <- Server, ts <- TS, u <- User, 
       tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})},
    {Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u, ma, Timestamp.ts, kab, nb>) |
       kab <- SessionKey, ma <- Nonce, nb <- Nonce, s <- Server, ts <- TS, 
       u <- User},
    {Sent.(Encrypt.(kab, <s, nb>), <u, s, as, ma, Timestamp.ts, kab, tkt, nb>) |
       as <- AuthenticationServer, kab <- SessionKey, ma <- Nonce, 
       nb <- Nonce, s <- Server, ts <- TS, u <- User, 
       tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})},
    { sm_ | (sm_,_) <- INTRUDER_M::All_External_and_Internal_Deductions}
  })

external relational_inverse_image
external relational_image
transparent chase
transparent sbisim

-- ************************************************************************
-- *                            Honest Agents                             *
-- ************************************************************************

module SYSTEM_M

  -- types of messages sent and received by agents, as they are
  -- considered by those agents

  input_proj((l_,m_,se_,re_)) = (l_,m_,re_)
  rmb_input_proj((l_,m_,se_,re_)) = ALGEBRA_M::rmb((l_,m_,re_))
  output_proj((l_,m_,se_,re_)) = (l_,m_,se_)

  INPUT_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  INPUT_INT_MSG = 
    
    Union({
      INPUT_INT_MSG1,
      INPUT_INT_MSG2a,
      INPUT_INT_MSG2b,
      INPUT_INT_MSG4a,
      INPUT_INT_MSG5,
      INPUT_INT_MSG6
    })

  OUTPUT_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  OUTPUT_INT_MSG = 
    
    Union({
      OUTPUT_INT_MSG1,
      OUTPUT_INT_MSG2a,
      OUTPUT_INT_MSG2b,
      OUTPUT_INT_MSG4a,
      OUTPUT_INT_MSG5,
      OUTPUT_INT_MSG6
    })

  -- USER

  USER_0(runTimeRemaining_, u, ma) =
      USER_0'(runTimeRemaining_, u, ma)

  USER_0'(runTimeRemaining_, u, ma) = 
    tock -> USER_0'(runTimeRemaining_, updt(u), updt(ma))
    [] 
    [] as : AuthenticationServer @ [] s : Server @ 
      member((Env0, Sq.<s, as>,<>), ENV_INT_MSG0) & 
      env_I.u.(Env0, Sq.<s, as>,<>) ->
    member((Msg1, Sq.<s, ma>,<>), OUTPUT_INT_MSG1) & 
    output.u.as.(Msg1, Sq.<s, ma>,<>) ->
      USER_0''(runTimeRemaining_, u, ma, as, s)

  USER_0''(runTimeRemaining_, u, ma, as, s) = 
    tock -> (if runTimeRemaining_ < 0 then SKIP
      else USER_0''(runTimeRemaining_-1, updt(u), updt(ma), updt(as), updt(s)))
    [] 
    [] kab : SessionKey @ [] ts : TS @ 
      member((Msg2a, Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>),<>), INPUT_INT_MSG2a) & 
      input.as.u.(Msg2a, Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>),<>) ->
      USER_0'''(runTimeRemaining_, u, ma, as, s, kab, ts)

  USER_0'''(runTimeRemaining_, u, ma, as, s, kab, ts) = 
    tock -> (if runTimeRemaining_ < 0 then SKIP
      else USER_0'''(runTimeRemaining_-1, updt(u), updt(ma), updt(as), updt(s), updt(kab), dects(ts)))
    [] 
    
    [] tkt : addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User}) @ 
      member((Msg2b, tkt,<>), INPUT_INT_MSG2b) & 
      input.as.u.(Msg2b, tkt,<>) ->
    member((Msg4a, tkt,<>), OUTPUT_INT_MSG4a) & 
    output.u.s.(Msg4a, tkt,<>) ->
      USER_0''''(runTimeRemaining_, u, ma, as, s, kab, ts, tkt)

  USER_0''''(runTimeRemaining_, u, ma, as, s, kab, ts, tkt) = 
    tock -> (if runTimeRemaining_ < 0 then SKIP
      else USER_0''''(runTimeRemaining_-1, updt(u), updt(ma), updt(as), updt(s), updt(kab), dects(ts), updt(tkt)))
    [] 
    [] nb : Nonce @ 
      member((Msg5, Sq.<nb, Encrypt.(inverse(kab), <ma, u>)>,<>), INPUT_INT_MSG5) & 
      input.s.u.(Msg5, Sq.<nb, Encrypt.(inverse(kab), <ma, u>)>,<>) ->
    member((Msg6, Encrypt.(kab, <s, nb>),<kab, as>), OUTPUT_INT_MSG6) & 
    output.u.s.(Msg6, Encrypt.(kab, <s, nb>),<kab, as>) ->
    SKIP

  USER_1(runTimeRemaining_, u, ma) = USER_0(runTimeRemaining_, u, ma)

  USER(runTimeRemaining_, u, ma) =
    USER_1(runTimeRemaining_, u, ma)
      [[input.as.u.(l_,m_,re_) <- receive.as.u.ALGEBRA_M::rmb((l_,m_,re_)) |
          as <- AuthenticationServer, (l_,m_,se_,re_) <- INT_MSG_INFO2a]]
      [[input.as.u.(l_,m_,re_) <- receive.as.u.ALGEBRA_M::rmb((l_,m_,re_)) |
          as <- AuthenticationServer, (l_,m_,se_,re_) <- INT_MSG_INFO2b]]
      [[input.s.u.(l_,m_,re_) <- receive.s.u.ALGEBRA_M::rmb((l_,m_,re_)) |
          s <- Server, (l_,m_,se_,re_) <- INT_MSG_INFO5]]
      [[output.u.as.(l_,m_,se_) <- send.u.as.ALGEBRA_M::rmb((l_,m_,se_)) |
          as <- AuthenticationServer, (l_,m_,se_,re_) <- INT_MSG_INFO1]]
      [[output.u.s.(l_,m_,se_) <- send.u.s.ALGEBRA_M::rmb((l_,m_,se_)) |
          s <- Server, (l_,m_,se_,re_) <- INT_MSG_INFO4a]]
      [[output.u.s.(l_,m_,se_) <- send.u.s.ALGEBRA_M::rmb((l_,m_,se_)) |
          s <- Server, (l_,m_,se_,re_) <- INT_MSG_INFO6]]
      [[env_I.u.m_ <- env.u.ALGEBRA_M::rmb(m_) |
          m_ <- ENV_INT_MSG0]]

  -- SERVER

  SERVER_0(runTimeRemaining_, s, nb) =
      SERVER_0'(runTimeRemaining_, s, nb)

  SERVER_0'(runTimeRemaining_, s, nb) = 
    tock -> SERVER_0'(runTimeRemaining_, updt(s), updt(nb))
    [] 
    [] kab : SessionKey @ [] ma : Nonce @ [] ts : TS @ [] u : User @ 
      member((Msg4a, Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>),<>), INPUT_INT_MSG4a) & 
      input.u.s.(Msg4a, Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>),<>) ->
    member((Msg5, Sq.<nb, Encrypt.(kab, <ma, u>)>,<kab>), OUTPUT_INT_MSG5) & 
    output.s.u.(Msg5, Sq.<nb, Encrypt.(kab, <ma, u>)>,<kab>) ->
      SERVER_0''(runTimeRemaining_, s, nb, kab, ma, ts, u)

  SERVER_0''(runTimeRemaining_, s, nb, kab, ma, ts, u) = 
    tock -> (if runTimeRemaining_ < 0 then SKIP
      else SERVER_0''(runTimeRemaining_-1, updt(s), updt(nb), updt(kab), updt(ma), dects(ts), updt(u)))
    [] 
    input.u.s.(Msg6, Encrypt.(inverse(kab), <s, nb>),<>) ->
    SKIP

  SERVER_1(runTimeRemaining_, s, nb) = SERVER_0(runTimeRemaining_, s, nb)

  SERVER(runTimeRemaining_, s, nb) =
    SERVER_1(runTimeRemaining_, s, nb)
      [[input.u.s.(l_,m_,re_) <- receive.u.s.ALGEBRA_M::rmb((l_,m_,re_)) |
          u <- User, (l_,m_,se_,re_) <- INT_MSG_INFO4a]]
      [[input.u.s.(l_,m_,re_) <- receive.u.s.ALGEBRA_M::rmb((l_,m_,re_)) |
          u <- User, (l_,m_,se_,re_) <- INT_MSG_INFO6]]
      [[output.s.u.(l_,m_,se_) <- send.s.u.ALGEBRA_M::rmb((l_,m_,se_)) |
          u <- User, (l_,m_,se_,re_) <- INT_MSG_INFO5]]

  -- AUTHSERVER

  AUTHSERVER_0(runTimeRemaining_, as, kab) =
      AUTHSERVER_0'(runTimeRemaining_, as, kab)

  AUTHSERVER_0'(runTimeRemaining_, as, kab) = 
    tock -> AUTHSERVER_0'(runTimeRemaining_, updt(as), updt(kab))
    [] 
    [] ma : Nonce @ [] s : Server @ [] u : User @ 
      member((Msg1, Sq.<s, ma>,<>), INPUT_INT_MSG1) & 
      input.u.as.(Msg1, Sq.<s, ma>,<>) ->
    [] ts : TS @ 
      member((Msg2a, Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>),<>), OUTPUT_INT_MSG2a) & 
      output.as.u.(Msg2a, Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>),<>) ->
    member((Msg2b, Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>),<>), OUTPUT_INT_MSG2b) & 
    output.as.u.(Msg2b, Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>),<>) ->
    SKIP

  AUTHSERVER_1(runTimeRemaining_, as, kab) = AUTHSERVER_0(runTimeRemaining_, as, kab)

  AUTHSERVER(runTimeRemaining_, as, kab) =
    AUTHSERVER_1(runTimeRemaining_, as, kab)
      [[input.u.as.(l_,m_,re_) <- receive.u.as.ALGEBRA_M::rmb((l_,m_,re_)) |
          u <- User, (l_,m_,se_,re_) <- INT_MSG_INFO1]]
      [[output.as.u.(l_,m_,se_) <- send.as.u.ALGEBRA_M::rmb((l_,m_,se_)) |
          u <- User, (l_,m_,se_,re_) <- INT_MSG_INFO2a]]
      [[output.as.u.(l_,m_,se_) <- send.as.u.ALGEBRA_M::rmb((l_,m_,se_)) |
          u <- User, (l_,m_,se_,re_) <- INT_MSG_INFO2b]]

  -- Process representing Alice

  Alpha_Alice = 
    Union({
      {|env.Alice|},
      {|send.Alice.A_ | A_ <- ALL_PRINCIPALS|},
      {tock}
    })

  AGENT_Alice = RUN({|tock|})

  -- Process representing Bob

  Alpha_USER_Bob = 
    Union({
      {|env.Bob.m_ | m_ <- ENV_MSG0|},
      {|send.Bob.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG1|},
      {|send.Bob.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG4a|},
      {|send.Bob.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG6|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2a|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2b|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG5|},
      {tock}
    })

  USER_Bob = ((USER(MaxRunTime, Bob, Nonce_P) ; RUN({tock}))
    [|{tock}|]
    (USER(MaxRunTime, Bob, Nonce_P) ; RUN({tock})))

  Alpha_Bob = 
    Union({
      {|env.Bob|},
      {|send.Bob.A_ | A_ <- ALL_PRINCIPALS|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2a|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2b|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG5|},
      {tock}
    })

  AGENT_Bob =
    (USER_Bob [Alpha_USER_Bob || {} ] STOP)

exports

  -- Messages as they appear on the network; each messages is renamed
  -- (by rmb) to the representative member of its equivalence class

  INPUT_MSG1 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG1}
  INPUT_MSG2a = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG2a}
  INPUT_MSG2b = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG2b}
  INPUT_MSG4a = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG4a}
  INPUT_MSG5 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG5}
  INPUT_MSG6 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG6}

  OUTPUT_MSG1 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG1}
  OUTPUT_MSG2a = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG2a}
  OUTPUT_MSG2b = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG2b}
  OUTPUT_MSG4a = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG4a}
  OUTPUT_MSG5 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG5}
  OUTPUT_MSG6 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG6}

  DIRECT_MSG1 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO1}
  DIRECT_MSG2a = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO2a}
  DIRECT_MSG2b = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO2b}
  DIRECT_MSG4a = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO4a}
  DIRECT_MSG5 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO5}
  DIRECT_MSG6 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO6}

  -- Environmental messages

  ENV_INT_MSG0 :: {(Labels, Encryption, <Encryption>)}
  ENV_INT_MSG0 = 
    {(Env0, Sq.<s, as>, <>) |
       as <- AuthenticationServer, s <- Server}

  ENV_MSG0 = {ALGEBRA_M::rmb(m_) | m_ <- ENV_INT_MSG0}

  ENV_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  ENV_INT_MSG = ENV_INT_MSG0

  -- information about messages sent and received by agents, including
  -- extras fields for both agents

  INT_MSG_INFO1_0 = 
    {(Msg1, Sq.<s, ma>, <>, <>) |
       ma <- Nonce, s <- Server}
  INT_MSG_INFO1 = 
    {(Msg1, m, s, r) | (Msg1,m,s,r) <- INT_MSG_INFO1_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO2a_0 = 
    {(Msg2a, Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>), <>, <>) |
       kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User}
  INT_MSG_INFO2a = 
    {(Msg2a, m, s, r) | (Msg2a,m,s,r) <- INT_MSG_INFO2a_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO2b_0 = 
    {(Msg2b, tkt, <>, <>) |
       tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})}
  INT_MSG_INFO2b = 
    {(Msg2b, m, s, r) | (Msg2b,m,s,r) <- INT_MSG_INFO2b_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO4a_0 = 
    {(Msg4a, tkt, <>, <>) |
       tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})}
  INT_MSG_INFO4a = 
    {(Msg4a, m, s, r) | (Msg4a,m,s,r) <- INT_MSG_INFO4a_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO5_0 = 
    {(Msg5, Sq.<nb, Encrypt.(kab, <ma, u>)>, <kab>, <>) |
       kab <- SessionKey, ma <- Nonce, nb <- Nonce, u <- User}
  INT_MSG_INFO5 = 
    {(Msg5, m, s, r) | (Msg5,m,s,r) <- INT_MSG_INFO5_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO6_0 = 
    {(Msg6, Encrypt.(kab, <s, nb>), <kab, as>, <>) |
       kab <- SessionKey, as <- AuthenticationServer, nb <- Nonce, 
       s <- Server}
  INT_MSG_INFO6 = 
    {(Msg6, m, s, r) | (Msg6,m,s,r) <- INT_MSG_INFO6_0,
      member(m,INTRUDER_M::KnowableFact)}

  ENV_MSG = {ALGEBRA_M::rmb(m_) | m_ <- ENV_INT_MSG}

  INT_MSG_INFO :: {(Labels, Encryption, <Encryption>, <Encryption>)}
  INT_MSG_INFO = 
    Union({
      INT_MSG_INFO1,
      INT_MSG_INFO2a,
      INT_MSG_INFO2b,
      INT_MSG_INFO4a,
      INT_MSG_INFO5,
      INT_MSG_INFO6
    })
  INPUT_INT_MSG1 = { input_proj(mt_) | mt_ <- INT_MSG_INFO1 }
  INPUT_INT_MSG2a = { input_proj(mt_) | mt_ <- INT_MSG_INFO2a }
  INPUT_INT_MSG2b = { input_proj(mt_) | mt_ <- INT_MSG_INFO2b }
  INPUT_INT_MSG4a = { input_proj(mt_) | mt_ <- INT_MSG_INFO4a }
  INPUT_INT_MSG5 = { input_proj(mt_) | mt_ <- INT_MSG_INFO5 }
  INPUT_INT_MSG6 = { input_proj(mt_) | mt_ <- INT_MSG_INFO6 }

  INPUT_MSG = 
    Union({
      INPUT_MSG1,
      INPUT_MSG2a,
      INPUT_MSG2b,
      INPUT_MSG4a,
      INPUT_MSG5,
      INPUT_MSG6
    })
  OUTPUT_INT_MSG1 = { output_proj(mt_) | mt_ <- INT_MSG_INFO1 }
  OUTPUT_INT_MSG2a = { output_proj(mt_) | mt_ <- INT_MSG_INFO2a }
  OUTPUT_INT_MSG2b = { output_proj(mt_) | mt_ <- INT_MSG_INFO2b }
  OUTPUT_INT_MSG4a = { output_proj(mt_) | mt_ <- INT_MSG_INFO4a }
  OUTPUT_INT_MSG5 = { output_proj(mt_) | mt_ <- INT_MSG_INFO5 }
  OUTPUT_INT_MSG6 = { output_proj(mt_) | mt_ <- INT_MSG_INFO6 }

  OUTPUT_MSG = 
    Union({
      OUTPUT_MSG1,
      OUTPUT_MSG2a,
      OUTPUT_MSG2b,
      OUTPUT_MSG4a,
      OUTPUT_MSG5,
      OUTPUT_MSG6
    })
  DIRECT_MSG = 
  Union({
    DIRECT_MSG1,
    DIRECT_MSG2a,
    DIRECT_MSG2b,
    DIRECT_MSG4a,
    DIRECT_MSG5,
    DIRECT_MSG6
  })

  channel input:ALL_PRINCIPALS.ALL_PRINCIPALS.INPUT_INT_MSG
  channel output: ALL_PRINCIPALS.ALL_PRINCIPALS.OUTPUT_INT_MSG
  channel env_I : ALL_PRINCIPALS.ENV_INT_MSG

  -- Complete system

  SYSTEM_0 =
    (AGENT_Alice
      [Alpha_Alice||Alpha_Bob]
    AGENT_Bob)

endmodule

-- ************************************************************************
-- *                               Algebra                                *
-- ************************************************************************

module ALGEBRA_M

  -- Algebraic laws, defined as a set of pairs

  laws = {(Garbage, Garbage)}

  -- Calculate transitive closure of algebraic laws, and select
  -- representative member of each equivalence class

  external mtransclose
  renaming = mtransclose(laws, Fact_1)
  ren = relational_inverse_image(renaming)

  -- function that renames non-sequential fact to representative member

  applyRenaming0(a_) =
    let S_ = ren(a_)
    within if card(S_)==0 then a_ else elsing(S_)

  elsing({x_}) = x_

  domain = {a_ | (_,a_) <- renaming}

exports

  -- function that renames arbitrary fact to representative member

  applyRenaming(Sq.ms_) =
    if member(Sq.ms_, Fact_1) then applyRenaming0(Sq.ms_) 
    else Sq.<applyRenaming0(m_) | m_ <- ms_>
  applyRenaming(a_) = applyRenaming0(a_)

  -- function that renames (label, fact, extras) triples

  rmb((l_,m_,extras_)) = 
    (l_, applyRenaming(m_), applyRenamingToSeq(extras_))
  rmb4((l_,m_,s_extras_,r_extras_)) = 
    (l_, applyRenaming(m_), applyRenamingToSeq(s_extras_), 
     applyRenamingToSeq(r_extras_))

  -- lift renaming to sets and to deductions

  applyRenamingToSet(X_) =
    union({elsing(ren(a_)) | a_ <- inter(X_,domain)},  diff(X_, domain))

  applyRenamingToSeq(X_) = <applyRenaming(e_) | e_ <- X_>

  applyRenamingToDeductions(S_) =
    {(applyRenaming0(f_), applyRenamingToSet(X_)) | (f_,X_) <- S_}

endmodule

-- ************************************************************************
-- *                             The Intruder                             *
-- ************************************************************************

module INTRUDER_M

  -- Unbound Parallel functions and sets, necessary for deductions

  honest(x) = x != Mallory

  -- Intruder's deductions

  unSq_ (Sq.ms_) = set(ms_)
  unSq_ (m_) = {m_}

  unknown_(S_) = diff(S_, IK0)

  Base_Deductions_ =
    Union({SqDeductions, UnSqDeductions, 
           EncryptionDeductions, DecryptionDeductions,
           VernEncDeductions, VernDecDeductions, 
           FnAppDeductions, HashDeductions,
           SentDeductions, All_Internal_Deductions, UserDeductions})

  SqDeductions =
    {(Sq.fs_, unknown_(set(fs_))) | Sq.fs_ <- Fact_1}

  UnSqDeductions =
    {(f_, unknown_({Sq.fs_})) | Sq.fs_ <- Fact_1, f_ <- unknown_(set(fs_))}

  EncryptionDeductions =
    {(Encrypt.(k_,fs_), unknown_(union({k_}, set(fs_)))) | 
        Encrypt.(k_,fs_) <- Fact_1}

  DecryptionDeductions =
    {(f_, unknown_({Encrypt.(k_,fs_), inverse(k_)})) |
        Encrypt.(k_,fs_) <- Fact_1, f_ <- unknown_(set(fs_))}

  VernEncDeductions =
    {(Xor.(m1_,m2_), unknown_(union(unSq_(m1_), unSq_(m2_)))) | 
        Xor.(m1_,m2_) <- Fact_1}

  VernDecDeductions =
      {(m11_, union(unknown_(unSq_(m2_)), {Xor.(m1_,m2_)})) | 
         Xor.(m1_,m2_) <- Fact_1, m11_ <- unSq_(m1_)}

  HashDeductions = {(Hash.(f_, ms_), set(ms_)) | Hash.(f_, ms_) <- Fact_1}

  -- Unbound Parallel Deductions

  SentDeductions = {(m_, {Sent.(m_,fs_)}) | Sent.(m_,fs_) <- Fact_1}

  -- The paramaterised deductions

  deductions_USER_0(u, ma, s, nb, as, kab) =
    Union({
      {( Sent.(Sq.<s, ma>, <u, as, s, ma>), {  })},
      {( Sent.(tkt, <u, s, as, ma, Timestamp.ts, kab, tkt>), 
        { Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>), tkt, Sent.(Sq.<s, ma>, <u, as, s, ma>) })
          | ts <- TS, tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})},
      {( Sent.(Encrypt.(kab, <s, nb>), <u, s, as, ma, Timestamp.ts, kab, tkt, nb>), 
        { Sq.<nb, Encrypt.(kab, <ma, u>)>, Sent.(tkt, <u, s, as, ma, Timestamp.ts, kab, tkt>) })
          | ts <- TS, tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})}
    })

  -- Deductions for internalised USER running with honest
  -- agent
  deductions_USER_with_honest =
    Union({
      deductions_USER_0(u, ma, s, nb, as, kab) |
        s <- Server, nb <- Nonce, as <- AuthenticationServer, kab <- SessionKey, u <- inter(User,HONEST), ma <- {Nonce_P}, honest(s) and honest(as)
      })

  -- Deductions for internalised USER running with dishonest
  -- agent.
  deductions_USER_with_dishonest =
    Union({
      deductions_USER_0(u, ma, s, nb, as, kab) |
        s <- Server, nb <- Nonce, as <- AuthenticationServer, kab <- SessionKey, u <- inter(User,HONEST), ma <- {Nonce_P}, not(honest(s) and honest(as))
      })

  -- Deductions for external USER running with any agent
  -- These are used to better approximate KnowableFact so as to reduce the
  -- size of LearnableFact.
  deductions_USER_external_0(u, ma, s, nb, as, kab) =
    Union({
      {( Sq.<s, ma>, {  })},
      {( tkt, 
        { Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>), tkt, Sq.<s, ma> })
          | ts <- TS, tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})},
      {( Encrypt.(kab, <s, nb>), { Sq.<nb, Encrypt.(kab, <ma, u>)>, tkt })
          | tkt <- addGarbage_({Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) | kab <- SessionKey, ma <- Nonce, s <- Server, ts <- TS, u <- User})}
    })

  deductions_USER_external = 
    Union({
      deductions_USER_external_0(u, ma, s, nb, as, kab) | 
        s <- Server, nb <- Nonce, as <- AuthenticationServer, kab <- SessionKey, u <- {Bob}, ma <- {}
    })

  -- The paramaterised deductions

  deductions_SERVER_0(u, ma, s, nb, as, kab) =
    {( Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u, ma, Timestamp.ts, kab, nb>), 
        { Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) })
          | ts <- TS}

  -- Deductions for internalised SERVER running with honest
  -- agent
  deductions_SERVER_with_honest =
    Union({
      deductions_SERVER_0(u, ma, s, nb, as, kab) |
        u <- User, ma <- Nonce, as <- AuthenticationServer, kab <- SessionKey, s <- inter(Server,HONEST), nb <- {Nonce_P}, honest(u) and honest(as)
      })

  -- Deductions for internalised SERVER running with dishonest
  -- agent.
  deductions_SERVER_with_dishonest =
    Union({
      deductions_SERVER_0(u, ma, s, nb, as, kab) |
        u <- User, ma <- Nonce, as <- AuthenticationServer, kab <- SessionKey, s <- inter(Server,HONEST), nb <- {Nonce_P}, not(honest(u) and honest(as))
      })

  -- Deductions for external SERVER running with any agent
  -- These are used to better approximate KnowableFact so as to reduce the
  -- size of LearnableFact.
  deductions_SERVER_external_0(u, ma, s, nb, as, kab) =
    {( Sq.<nb, Encrypt.(kab, <ma, u>)>, 
        { Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>) })
          | ts <- TS}

  deductions_SERVER_external = 
    Union({
      deductions_SERVER_external_0(u, ma, s, nb, as, kab) | 
        u <- User, ma <- Nonce, as <- AuthenticationServer, kab <- SessionKey, s <- {}, nb <- {}
    })

  -- The paramaterised deductions

  deductions_AUTHSERVER_0(u, ma, s, nb, as, kab) =
    Union({
      {( Sent.(Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>), <as, u, s, ma, Timestamp.ts, kab>), 
        { Sq.<s, ma> })
          | ts <- TS},
      {( Sent.(Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>), <as, u, s, ma, Timestamp.ts, kab>), 
        { Sent.(Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>), <as, u, s, ma, Timestamp.ts, kab>) })
          | ts <- TS}
    })

  -- Deductions for internalised AUTHSERVER running with honest
  -- agent
  deductions_AUTHSERVER_with_honest =
    Union({
      deductions_AUTHSERVER_0(u, ma, s, nb, as, kab) |
        u <- User, ma <- Nonce, s <- Server, nb <- Nonce, as <- inter(AuthenticationServer,HONEST), kab <- {kab_S, SessionKey_S}, honest(u) and honest(s)
      })

  -- Deductions for internalised AUTHSERVER running with dishonest
  -- agent.
  deductions_AUTHSERVER_with_dishonest =
    Union({
      deductions_AUTHSERVER_0(u, ma, s, nb, as, kab) |
        u <- User, ma <- Nonce, s <- Server, nb <- Nonce, as <- inter(AuthenticationServer,HONEST), kab <- {SessionKey_P}, not(honest(u) and honest(s))
      })

  -- Deductions for external AUTHSERVER running with any agent
  -- These are used to better approximate KnowableFact so as to reduce the
  -- size of LearnableFact.
  deductions_AUTHSERVER_external_0(u, ma, s, nb, as, kab) =
    Union({
      {( Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>), { Sq.<s, ma> })
          | ts <- TS},
      {( Encrypt.(SKey__.(s), <ma, Timestamp.ts, kab, u>), 
        { Encrypt.(UKey__.(u), <ma, Timestamp.ts, s, kab>) })
          | ts <- TS}
    })

  deductions_AUTHSERVER_external = 
    Union({
      deductions_AUTHSERVER_external_0(u, ma, s, nb, as, kab) | 
        u <- User, ma <- Nonce, s <- Server, nb <- Nonce, as <- {}, kab <- {}
    })

  All_Internal_Deductions = 
    Union({
      deductions_USER_with_honest,
      deductions_SERVER_with_honest,
      deductions_AUTHSERVER_with_honest,
      deductions_USER_with_dishonest,
      deductions_SERVER_with_dishonest,
      deductions_AUTHSERVER_with_dishonest
    })

  All_External_and_Internal_Deductions_ = 
    Union({
      All_Internal_Deductions,
      deductions_USER_external,
      deductions_SERVER_external,
      deductions_AUTHSERVER_external
    })

  All_Deductions = Union({Base_Deductions, All_External_and_Internal_Deductions})

  UserDeductions = {}

  FnAppDeductions = {}

  -- close up intruder's initial knowledge under deductions;
  -- calculate which facts cannot be learnt

  components_(Sq.ms_) = 
    if member(Sq.ms_, Fact_1) then {Sq.ms_} else set(ms_)
  components_(m_) = {m_}

  Seeable_ = 
    Union({unknown_(components_(m_)) | (_,m_,_,_) <- SYSTEM_M::INT_MSG_INFO})

  -- The intruder

  -- * leak is used to signal that a possible secret has been learnt
  -- * hear and say are used to represent hearing or saying a message
  -- * infer(f,fs) represent deducing fact f from the set of facts fs

  -- Component of intruder for currently unknown fact f_:
  -- * ms_ is the set of messages that contain f_ at the top level
  -- * fss_ is the set of sets of facts from which f_ can be deduced
  -- * ds_ is the set of deductions that use f_

  IGNORANT(f_,ms_,fss_,ds_) =
    hear?m_:ms_ -> KNOWS(f_,ms_,fss_,ds_)
    []
    ([] fs_ : fss_, not(member(f_,fs_)) @ 
        infer.(f_,fs_) -> KNOWS(f_,ms_,fss_,ds_))
    [] tock -> (IGNORANT(f_,ms_,fss_,ds_)
      -- We can only be the updated version if there is a fact that can
      -- be updated to us.
      [] card({f1_ | f1_ <- UpdateableFacts, updt(f1_) == f_, f_ != f1_}) > 0 &
          tockInfer.f_ -> KNOWS(f_,ms_,fss_,ds_))

  -- Component of intruder for known fact f_

  KNOWS(f_,ms_,fss_,ds_) =
    hear?m_:ms_ -> KNOWS(f_,ms_,fss_,ds_)
    []
    say?m_:ms_ -> KNOWS(f_,ms_,fss_,ds_)
    [] 
    ([] ded@@(f1_,fs_) : ds_, f1_!=f_ @ infer.ded -> KNOWS(f_,ms_,fss_,ds_))
    []
    member(f_,ALL_SECRETS) & leak.f_ -> KNOWS(f_,ms_,fss_,ds_)
    [] tock ->
      (if updt(f_) != f_ then
        tockInfer.updt(f_) -> IGNORANT(f_,ms_,fss_,ds_)
      else -- Allow more infers (consider if we obtain a fresher version of this message)
        KNOWS(f_,ms_,fss_,ds_)
        [] tockInfer.f_ -> KNOWS(f_,ms_,fss_,ds_))

  -- Alphabet of this component

  AlphaL(f_,ms_,fss_,ds_) =
    Union({(if member(f_,ALL_SECRETS) then {leak.f_} else {}),
           {hear.m_, say.m_ | m_ <- ms_},
           {infer.(f_,fs_) | fs_ <- fss_},
           {infer.(f1_,fs_) | (f1_,fs_) <- ds_},
           {tock, tockInfer.f_, tockInfer.updt(f_)}
         })

  -- Set of all (f_, ms_, fss_, ds_) for which intruder components 
  -- must be built

  f_ms_fss_ds_s(Deductions,LearnableFact) = 
    let rid_ = relational_image(Deductions)
        msf_ = relational_image({(f_, m_) | m_ <- MSG_BODY, f_ <- unSq_(m_)})
        xsf_ = relational_image({(f_, x_) | x_@@(_,fs_) <- Deductions,
                                            f_ <- fs_})
    within {(f_, msf_(f_), rid_(f_), xsf_(f_)) | f_ <- LearnableFact}

  -- Rename events appropriately

  BUILD_INTRUDER_0(INTRUDER_0) =
    ((chase(INTRUDER_0)
      [[ hear.m_ <- hear.m_, hear.m_ <- send.A_.B_.(l_,m_,se_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2a,
           SYSTEM_M::DIRECT_MSG2b,
           SYSTEM_M::DIRECT_MSG4a,
           SYSTEM_M::DIRECT_MSG5,
           SYSTEM_M::DIRECT_MSG6
         }), 
         A_ <- diff(SenderType(l_),{Mallory}), 
         B_ <- ReceiverType(l_) ]] 
     [|{| hear |}|] STOP)
      [[ say.m_ <- receive.A_.B_.(l_,m_,re_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2a,
           SYSTEM_M::DIRECT_MSG2b,
           SYSTEM_M::DIRECT_MSG4a,
           SYSTEM_M::DIRECT_MSG5,
           SYSTEM_M::DIRECT_MSG6
         }), 
         A_ <- SenderType(l_), 
         B_ <- ReceiverType(l_) ]] 
     [|{| say |}|] STOP)

  -- Add in facts that are known initially

  SAY_KNOWN_0(IK1) = 
    (inter(IK1, ALL_SECRETS) != {} & dummy_leak -> SAY_KNOWN_0(IK1)) 
    [] dummy_send -> SAY_KNOWN_0(IK1) 
    [] dummy_receive -> SAY_KNOWN_0(IK1) 

  SAY_KNOWN(IK1) =
    SAY_KNOWN_0(IK1)
      [[ dummy_leak <- leak.f_ | f_ <- inter(IK1, ALL_SECRETS) ]]
      [[ dummy_send <- dummy_send, dummy_send <- send.A_.B_.(l_,m_,se_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2a,
           SYSTEM_M::DIRECT_MSG2b,
           SYSTEM_M::DIRECT_MSG4a,
           SYSTEM_M::DIRECT_MSG5,
           SYSTEM_M::DIRECT_MSG6
         }), components_(m_) <= IK1, 
         A_ <- diff(SenderType(l_),{Mallory}), 
         B_ <- ReceiverType(l_) ]] 
      [[ dummy_receive <- dummy_receive, dummy_receive <- receive.A_.B_.(l_,m_,re_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2a,
           SYSTEM_M::DIRECT_MSG2b,
           SYSTEM_M::DIRECT_MSG4a,
           SYSTEM_M::DIRECT_MSG5,
           SYSTEM_M::DIRECT_MSG6
         }), components_(m_) <= IK1, 
         A_ <- SenderType(l_), 
         B_ <- ReceiverType(l_) ]] 

  STOP_SET = { dummy_send, dummy_receive }

exports

  -- Types of sender and receiver of each message

  SenderType (Msg1) = User
  SenderType (Msg2a) = AuthenticationServer
  SenderType (Msg2b) = AuthenticationServer
  SenderType (Msg4a) = User
  SenderType (Msg5) = Server
  SenderType (Msg6) = User

  ReceiverType(Msg1) = AuthenticationServer
  ReceiverType(Msg2a) = User
  ReceiverType(Msg2b) = User
  ReceiverType(Msg4a) = Server
  ReceiverType(Msg5) = User
  ReceiverType(Msg6) = Server

  -- Intruder's initial knowledge

  IK0 = union({Mallory, UKey__.(Mallory), Alice, Alice, Alice, Bob, Nonce_P, 
             SessionKey_P, Garbage}, TimeStamp)

  Base_Deductions = Base_Deductions_

  All_External_and_Internal_Deductions =  All_External_and_Internal_Deductions_

  Close_(IK_, ded_, fact_) =
    CloseButNotFacts_(IK_, ded_, fact_, { })

  -- The method below is used to calculate IK1 and Deductions and is important
  -- when authentication checks are being done. If no check was done on f being
  -- in Facts then the infer event corresponding to a signal may be hidden.
  CloseButNotFacts_(IK_, ded_, fact_, signal_facts_) =
    let IK1_ = 
          union(IK_, {f_ | (f_,fs_) <- ded_, fs_ <= IK_ and not member(f_, signal_facts_)})
        ded1_ = 
          {(f_,fs_) | (f_,fs_) <- ded_, not (member(f_,IK_)),
                      fs_ <= fact_}
    within
    if card(IK_)==card(IK1_) and card(ded_)==card(ded1_)
    then (IK_, {(f_,diff(fs_,IK_)) | (f_,fs_) <- ded_})
    else CloseButNotFacts_(IK1_, ded1_, fact_, signal_facts_)

  -- Calculate knowable facts based using the external and internal deductions
  (KnowableFact_, _) = 
    Close_(ALGEBRA_M::applyRenamingToSet(IK0), 
           ALGEBRA_M::applyRenamingToDeductions(All_Deductions), 
           ALGEBRA_M::applyRenamingToSet(Fact_1))

KnowableFact = KnowableFact_ 
  -- Put components together in parallel
  INTRUDER_00(Deductions,LearnableFact) = 
    (|| (f_,ms_,fss_,ds_) : f_ms_fss_ds_s(Deductions,LearnableFact) @ 
         [AlphaL(f_,ms_,fss_,ds_)] IGNORANT(f_,ms_,fss_,ds_))

  -- Set of all deductions that could occur
  COMBINED_DEDUCTIONS =
    let ds_ = 
        Union({
          AUTH1_M::RenamedDeductions,
          AUTH2_M::RenamedDeductions,
          SECRET_M::Deductions
        })
    within -- Don't you hate hacks like this (FDR does not allow empty channel types)?
      if ds_ == {} then {(Garbage, {Garbage})} else ds_

  -- Declare channels:
  channel hear, say : MSG_BODY
  channel dummy_leak, dummy_send, dummy_receive
  UpdateableFacts = union({f_ | (f_,fs_) <- COMBINED_DEDUCTIONS},KnowableFact)
  channel tockInfer : UpdateableFacts

  -- Complete intruder

  -- Intruder used for temporal specs
  BUILD_INTRUDER'(INTRUDER_0,IK) =
    (BUILD_INTRUDER_0(INTRUDER_0) ||| SAY_KNOWN(IK)) [| STOP_SET |] STOP

endmodule

-- FDR bug: cannot have a module prefix in a channel type
Deductions' = INTRUDER_M::COMBINED_DEDUCTIONS
channel infer : Deductions'

IntruderInterface = 
  Union({
    {| receive.Mallory.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| receive.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- Union({
      SYSTEM_M::INPUT_MSG1,
      SYSTEM_M::INPUT_MSG2a,
      SYSTEM_M::INPUT_MSG2b,
      SYSTEM_M::INPUT_MSG4a,
      SYSTEM_M::INPUT_MSG5,
      SYSTEM_M::INPUT_MSG6
    }) |},
    {| send.A_.Mallory.m_ | A_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- Union({
      SYSTEM_M::OUTPUT_MSG1,
      SYSTEM_M::OUTPUT_MSG2a,
      SYSTEM_M::OUTPUT_MSG2b,
      SYSTEM_M::OUTPUT_MSG4a,
      SYSTEM_M::OUTPUT_MSG5,
      SYSTEM_M::OUTPUT_MSG6
    }) |},
    {tock}
  })

-- ************************************************************************
-- *                    Specifications and Assertions                     *
-- ************************************************************************

module SECRET_M

  -- Specification for single secret

  SECRET_SPEC_0(s_) = 
    signal.Claim_Secret?A_!s_?Bs_ ->
      (if member(Mallory, Bs_) then SECRET_SPEC_0(s_)
       else SECRET_SPEC_1(s_))
    []
    leak.s_ -> SECRET_SPEC_0(s_)
  SECRET_SPEC_1(s_) = 
    signal.Claim_Secret?A_!s_?Bs_ -> SECRET_SPEC_1(s_)
  -- Specification for all secrets

  AlphaS(s_) = 
    Union({
      {|signal.Claim_Secret.A_.s_ | A_ <- ALL_PRINCIPALS|},
      {leak.s_}
    })
  -- Sequential version; secs_ is secrets that intruder must not learn

  SEQ_SECRET_SPEC_0(secs_) =
    scs?s_!IntIn -> SEQ_SECRET_SPEC_0(secs_)
    []
    card(secs_)<2 & scs?s_!IntNotIn ->
      SEQ_SECRET_SPEC_0(union(secs_,{s_}))
    []
    card(secs_)==2 & scs?s_:secs_!IntNotIn ->
      SEQ_SECRET_SPEC_0(secs_)
    []
    leak?s_ : diff(ALL_SECRETS,secs_) -> SEQ_SECRET_SPEC_0(secs_)

  isIntIn(S_) = if member(Mallory,S_) then IntIn else IntNotIn

  Alpha_SECRETS =
    Union({
      {|leak, signal.Claim_Secret.A_ | A_ <- HONEST|}
    })

  Alpha_SEQ_SECRETS = 
    Union({
      {|leak, scs|}
    })

exports

  (IK, Deductions) =
   INTRUDER_M::Close_(ALGEBRA_M::applyRenamingToSet(INTRUDER_M::IK0), 
           ALGEBRA_M::applyRenamingToDeductions(INTRUDER_M::Base_Deductions), 
           ALGEBRA_M::applyRenamingToSet(INTRUDER_M::KnowableFact))

  LearnableFact = diff(INTRUDER_M::KnowableFact, IK)

  INTRUDER_0 =
    INTRUDER_M::INTRUDER_00(Deductions,LearnableFact) \ {|infer,INTRUDER_M::tockInfer|}

  SYSTEM =
    SYSTEM_M::SYSTEM_0 [| IntruderInterface |] INTRUDER_M::BUILD_INTRUDER'(INTRUDER_0,IK)

  SECRET_SPEC = (|| s_ : ALL_SECRETS @ [AlphaS(s_)] SECRET_SPEC_0(s_))

  datatype IncInt = IntIn | IntNotIn

  channel scs : ALL_SECRETS.IncInt

  SEQ_SECRET_SPEC = SEQ_SECRET_SPEC_0({})

  -- System for secrecy checking

  SYSTEM_S = 
    let User_renamed_ = ALGEBRA_M::applyRenamingToSet(User)
        Server_renamed_ = ALGEBRA_M::applyRenamingToSet(Server)
        SessionKey_renamed_ = ALGEBRA_M::applyRenamingToSet(SessionKey)
        AuthenticationServer_renamed_ = ALGEBRA_M::applyRenamingToSet(AuthenticationServer)
        Nonce_renamed_ = ALGEBRA_M::applyRenamingToSet(Nonce)
    within
    SYSTEM
      [[send.u.s.ALGEBRA_M::rmb((Msg6, Encrypt.(kab, <s, nb>), <kab, as>))
          <- signal.Claim_Secret.u.ALGEBRA_M::applyRenaming(kab).{s, as} |
            u <- User_renamed_, s <- Server_renamed_, 
            kab <- SessionKey_renamed_, as <- AuthenticationServer_renamed_, 
            nb <- Nonce_renamed_,
        member(ALGEBRA_M::rmb((Msg6, Encrypt.(kab, <s, nb>), <kab, as>)),SYSTEM_M::OUTPUT_MSG6)
      ]] \ {| env, send, receive, tock |}

  SYSTEM_S_SEQ =
    let User_renamed_ = ALGEBRA_M::applyRenamingToSet(User)
        Server_renamed_ = ALGEBRA_M::applyRenamingToSet(Server)
        SessionKey_renamed_ = ALGEBRA_M::applyRenamingToSet(SessionKey)
        AuthenticationServer_renamed_ = ALGEBRA_M::applyRenamingToSet(AuthenticationServer)
        Nonce_renamed_ = ALGEBRA_M::applyRenamingToSet(Nonce)
    within
    SYSTEM
      [[send.u.s.ALGEBRA_M::rmb((Msg6, Encrypt.(kab, <s, nb>), <kab, as>))
          <- scs.ALGEBRA_M::applyRenaming(kab).isIntIn({u, s, as}) |
            u <- User_renamed_, s <- Server_renamed_, 
            kab <- SessionKey_renamed_, as <- AuthenticationServer_renamed_, 
            nb <- Nonce_renamed_,
        member(ALGEBRA_M::rmb((Msg6, Encrypt.(kab, <s, nb>), <kab, as>)),SYSTEM_M::OUTPUT_MSG6)
      ]] \ {| env, send, receive, tock |}

endmodule

-- Assertion of secrecy

assert SECRET_M::SECRET_SPEC [T= SECRET_M::SYSTEM_S
assert SECRET_M::SEQ_SECRET_SPEC [T= SECRET_M::SYSTEM_S_SEQ

-- ************************************************************************
-- *                    Authentication specifications                     *
-- ************************************************************************

module AUTH_COMMON
  createRenaming(factsRenaming) =
    let rn = relational_image(factsRenaming)
        dom = {a_ | (a_, _) <- factsRenaming}
        extract({x_}) = x_
    within \ x_ @ if member(x_,dom) then extract(rn(x_)) else x_

  -- The first argument is something of type createRenaming(X)
  renameSet(f_, X_) =
    {f_(x_) | x_ <- X_}
  renameDeductions(rn_, ds_) =
    {(rn_(f_), renameSet(rn_, fs_)) | (f_, fs_) <- ds_}

exports
  -- Given a set of pairs (f, f') first compute the closure (but excluding
  -- any facts in factsToRename) of the intruder's initial knowledge and then
  -- rename all facts that appear in Deductions and LearnableFact.
  RenameClosure(factsRenaming,factsToRename) = 
    let
      rn_ = createRenaming(factsRenaming)
      (IK_,ded_) =
        INTRUDER_M::CloseButNotFacts_(
          ALGEBRA_M::applyRenamingToSet(INTRUDER_M::IK0),
          ALGEBRA_M::applyRenamingToDeductions(INTRUDER_M::Base_Deductions),
          ALGEBRA_M::applyRenamingToSet(INTRUDER_M::KnowableFact),
          factsToRename)
      learnableFact = diff(INTRUDER_M::KnowableFact,IK_)
    within
      (renameDeductions(rn_,ded_), IK_, renameSet(rn_,learnableFact))

  -- System to be used for checking authentication specifications
  AUTH_SYSTEM(INTRUDER_0,IK) = 
    SYSTEM_M::SYSTEM_0
    [| IntruderInterface |] INTRUDER_M::BUILD_INTRUDER'(INTRUDER_0,IK)

endmodule

-- ************************************************************************
-- *                 Authentication specification number 1                *
-- ************************************************************************

module AUTH1_M

  -- Set of all facts that would be renamed to signals in infer events
  FACTS_TO_RENAME = 
    {Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>) | 
      Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>) <- INTRUDER_M::KnowableFact}

  -- Set of tuples of the form (Fact, RunningFact) that is used to create a
  -- renaming function of type Fact -> RunningFact.
  FACT_RENAMING =
    Union({
      {(Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>), AuthTaggedSignals1.TRunning1.s.u.kab.Internal)
      | Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>) <- FACTS_TO_RENAME,
        u_2_ == u, ma_2_ == ma, kab_2_ == kab, nb_2_ == nb,
        not((member(ma,{Nonce_P})))},
      {(Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>), AuthTaggedSignals1.TRunning1.s.u.kab.External1)
      | Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>) <- FACTS_TO_RENAME,
        u_2_ == u, ma_2_ == ma, kab_2_ == kab, nb_2_ == nb,
        member(ma,{Nonce_P})}
    })

  (RenamedDeductions_,IK,RenamedLearnableFact) =
    AUTH_COMMON::RenameClosure(FACT_RENAMING,FACTS_TO_RENAME)

  -- Build the basic (non-chased) intruder by renaming all the infer.(f,fs)
  -- events corresponding to the messages that should be renamed.
  INTRUDER_0 = 
    INTRUDER_M::INTRUDER_00(RenamedDeductions,RenamedLearnableFact)
      [[infer.(AuthTaggedSignals1.TRunning1.s.u.kab.tag_,fs_) <-
         signal.Running1.SERVER_role.s.u.kab
        | (AuthTaggedSignals1.TRunning1.s.u.kab.tag_, fs_) <- RenamedDeductions,
          member(s,inter(Server,HONEST)), member(u, {Bob})
      ]] \ {|infer,INTRUDER_M::tockInfer|}

exports
  RenamedDeductions = RenamedDeductions_

  -- Datatypes below are what facts are renamed in in FACT_RENAMING above
  datatype Tag1 = Internal | External1
  datatype TaggedSignals1 = TRunning1.ALL_PRINCIPALS.ALL_PRINCIPALS.SessionKey.Tag1

  -- Specs for all agents being authenticated

  AuthenticateSERVERToUSERNonInjectiveAgreement_kab =
    let
      bInstance(u, ma) =
        signal.Running1.SERVER_role?s : inter(Server,HONEST)!u?kab : {kab_S, SessionKey_S} ->
          RUN({signal.Commit1.USER_role.u.s.kab})
      run(u, ma) = 
        signal.Running1.SERVER_role?s : inter(Server,HONEST)!u?kab -> 
        run(u, ma)
    within
      -- Number argument tuples so that duplicates are not eliminated
      ||| (_,u, ma): {(1, Bob, Nonce_P), (2, Bob, Nonce_P)} @
        sbisim(bInstance(u, ma)) ||| run(u, ma)

  -- System for authentication checking

  SYSTEM_1 =
    let Server_renamed_ = ALGEBRA_M::applyRenamingToSet(Server)
        User_renamed_ = ALGEBRA_M::applyRenamingToSet(User)
        SessionKey_renamed_ = ALGEBRA_M::applyRenamingToSet(SessionKey)
        Nonce_renamed_ = ALGEBRA_M::applyRenamingToSet(Nonce)
        AuthenticationServer_renamed_ = ALGEBRA_M::applyRenamingToSet(AuthenticationServer)
    within
      AUTH_COMMON::AUTH_SYSTEM(INTRUDER_0,IK)
       [[send.s.u.ALGEBRA_M::rmb((Msg5, Sq.<nb, Encrypt.(kab, <ma, u>)>, <kab>)) <-
          signal.Running1.SERVER_role.s.u.kab,  
        send.u.s.ALGEBRA_M::rmb((Msg6, Encrypt.(kab, <s, nb>), <kab, as>)) <-
          signal.Commit1.USER_role.u.s.kab |
            s <- Server_renamed_, u <- User_renamed_, 
            kab <- SessionKey_renamed_, ma <- Nonce_renamed_, 
            nb <- Nonce_renamed_, as <- AuthenticationServer_renamed_,
            member(s,HONEST),
            member((Msg5, Sq.<nb, Encrypt.(kab, <ma, u>)>, <kab>),SYSTEM_M::OUTPUT_MSG5),
            member((Msg6, Encrypt.(kab, <s, nb>), <kab, as>),SYSTEM_M::OUTPUT_MSG6)
      ]]
      \ {| env, leak, send, receive, tock|}

endmodule

assert AUTH1_M::AuthenticateSERVERToUSERNonInjectiveAgreement_kab [T= 
       AUTH1_M::SYSTEM_1

-- ************************************************************************
-- *                 Authentication specification number 2                *
-- ************************************************************************

module AUTH2_M

  -- Set of all facts that would be renamed to signals in infer events
  FACTS_TO_RENAME = 
    {Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>) | 
      Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>) <- INTRUDER_M::KnowableFact}

  -- Set of tuples of the form (Fact, RunningFact) that is used to create a
  -- renaming function of type Fact -> RunningFact.
  FACT_RENAMING =
    Union({
      {(Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>), AuthTaggedSignals2.TRunning2.s.u.kab.Internal)
      | Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>) <- FACTS_TO_RENAME,
        u_2_ == u, ma_2_ == ma, kab_2_ == kab, nb_2_ == nb,
        not((member(ma,{Nonce_P})))},
      {(Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>), AuthTaggedSignals2.TRunning2.s.u.kab.External1)
      | Sent.(Sq.<nb, Encrypt.(kab, <ma, u>)>, <s, u_2_, ma_2_, Timestamp.ts, kab_2_, nb_2_>) <- FACTS_TO_RENAME,
        u_2_ == u, ma_2_ == ma, kab_2_ == kab, nb_2_ == nb,
        member(ma,{Nonce_P})}
    })

  (RenamedDeductions_,IK,RenamedLearnableFact) =
    AUTH_COMMON::RenameClosure(FACT_RENAMING,FACTS_TO_RENAME)

  -- Build the basic (non-chased) intruder by renaming all the infer.(f,fs)
  -- events corresponding to the messages that should be renamed.
  INTRUDER_0 = 
    INTRUDER_M::INTRUDER_00(RenamedDeductions,RenamedLearnableFact)
      [[infer.(AuthTaggedSignals2.TRunning2.s.u.kab.tag_,fs_) <-
         signal.Running2.SERVER_role.s.u.kab
        | (AuthTaggedSignals2.TRunning2.s.u.kab.tag_, fs_) <- RenamedDeductions,
          member(s,inter(Server,HONEST)), member(u, {Bob})
      ]] \ {|infer,INTRUDER_M::tockInfer|}

exports
  RenamedDeductions = RenamedDeductions_

  -- Datatypes below are what facts are renamed in in FACT_RENAMING above
  datatype Tag2 = Internal | External1
  datatype TaggedSignals2 = TRunning2.ALL_PRINCIPALS.ALL_PRINCIPALS.SessionKey.Tag2

  -- Specs for all agents being authenticated

  AuthenticateSERVERToUSERAgreement_kab =
    let
      bInstance(u, ma) =
        signal.Running2.SERVER_role?s : inter(Server,HONEST)!u?kab : {kab_S, SessionKey_S} ->
          signal.Commit2.USER_role.u.s.kab -> STOP
      run(u, ma) = 
        signal.Running2.SERVER_role?s : inter(Server,HONEST)!u?kab -> 
        run(u, ma)
    within
      -- Number argument tuples so that duplicates are not eliminated
      ||| (_,u, ma): {(1, Bob, Nonce_P), (2, Bob, Nonce_P)} @
        sbisim(bInstance(u, ma)) ||| run(u, ma)

  -- System for authentication checking

  SYSTEM_2 =
    let Server_renamed_ = ALGEBRA_M::applyRenamingToSet(Server)
        User_renamed_ = ALGEBRA_M::applyRenamingToSet(User)
        SessionKey_renamed_ = ALGEBRA_M::applyRenamingToSet(SessionKey)
        Nonce_renamed_ = ALGEBRA_M::applyRenamingToSet(Nonce)
        AuthenticationServer_renamed_ = ALGEBRA_M::applyRenamingToSet(AuthenticationServer)
    within
      AUTH_COMMON::AUTH_SYSTEM(INTRUDER_0,IK)
       [[send.s.u.ALGEBRA_M::rmb((Msg5, Sq.<nb, Encrypt.(kab, <ma, u>)>, <kab>)) <-
          signal.Running2.SERVER_role.s.u.kab,  
        send.u.s.ALGEBRA_M::rmb((Msg6, Encrypt.(kab, <s, nb>), <kab, as>)) <-
          signal.Commit2.USER_role.u.s.kab |
            s <- Server_renamed_, u <- User_renamed_, 
            kab <- SessionKey_renamed_, ma <- Nonce_renamed_, 
            nb <- Nonce_renamed_, as <- AuthenticationServer_renamed_,
            member(s,HONEST),
            member((Msg5, Sq.<nb, Encrypt.(kab, <ma, u>)>, <kab>),SYSTEM_M::OUTPUT_MSG5),
            member((Msg6, Encrypt.(kab, <s, nb>), <kab, as>),SYSTEM_M::OUTPUT_MSG6)
      ]]
      \ {| env, leak, send, receive, tock|}

endmodule

assert AUTH2_M::AuthenticateSERVERToUSERAgreement_kab [T= 
       AUTH2_M::SYSTEM_2

