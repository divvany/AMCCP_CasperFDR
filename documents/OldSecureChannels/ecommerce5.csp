-- CSP script produced using Casper version 2.0

-- -- Simple e-commerce protocol
-- -- CSP edited by hand
-- #Free variables
-- 
-- c, m  : Agent
-- b : Bank
-- sn : SeqNo
-- order : Order
-- price : Price
-- result : Result
-- PK : Agent -> PublicKey
-- SK : Agent -> SecretKey
-- BPK : Bank -> BankPublicKey
-- BSK : Bank -> BankSecretKey
-- InverseKeys = (PK,SK), (BPK, BSK)
-- 
-- #Processes
-- 
-- CUSTOMER(c,sn) knows SK(c), BPK
-- MERCHANT(m)
-- BANK(b) knows PK, BSK(b)
-- 
-- #Protocol description
-- 
-- 0.   -> c : m, b, order, price
-- [c!=m]
-- 1. c -> m : b, order, price, {b, price, sn}{SK(c)}%sig
-- 2. m -> b : c, price, sig%{b, price, sn}{SK(c)}
-- [m!=c]
-- 2a.  -> b : result
-- 3. b -> m : result, {c, result}{BSK(b)}%bsig
-- 4. m -> c : result, bsig%{c, result}{BSK(b)}
-- 
-- #Channels
-- 
-- authenticated
-- secret
-- -- direct
-- 
-- #Specification
-- 
-- -- PASS
-- Agreement(c, m, [b, order, price])
-- -- PASS
-- Agreement(b, m, [c, price, result])
-- -- FAIL
-- Agreement(c, b, [m, price])
-- -- FAIL
-- Agreement(b, c, [m, price, result])
-- -- FAIL
-- Secret(c, order, [m])
-- -- FAIL
-- Secret(m, order, [c])
-- -- PASS
-- Agreement(m, c, [b, order, price])
-- -- PASS
-- Agreement(m, b, [c, price])
-- 
-- #Functions
-- 
-- symbolic PK, SK, BPK, BSK
-- 
-- #Actual variables
-- 
-- C, M, I  : Agent
-- B : Bank
-- O : Order
-- P : Price
-- SN1, SN2 : SeqNo
-- Yes, No : Result
-- 
-- #System
-- 
-- CUSTOMER(C, SN1)
-- CUSTOMER(C, SN2)
-- MERCHANT(M)
-- BANK(B)
-- BANK(B)
-- 
-- #Intruder Information
-- 
-- Intruder = I
-- IntruderKnowledge = {I, C, M, B, O, P, Yes, No, PK, SK(I), SN1}
-- 

-- ************************************************************************
-- *                                Types                                 *
-- ************************************************************************

-- Main datatype, representing all possible messages

datatype Encryption =
  C | M | I | B | O | P | SN1 | SN2 | Yes | No | Garbage | PK__.Agent | 
  SK__.Agent | BPK__.Bank | BSK__.Bank | Sq.Seq(Encryption) | 
  Encrypt.(ALL_KEYS,Seq(Encryption)) | Hash.(HashFunction, Seq(Encryption)) | 
  Xor.(Encryption, Encryption)

-- All keys and hashfunctions in the system

ALL_KEYS :: {Encryption}
ALL_KEYS = Union({BankSecretKey, SecretKey})

ASYMMETRIC_KEYS = {k_, inverse(k_) | k_ <- ALL_KEYS, k_!=inverse(k_)}
HashFunction :: {Encryption}
HashFunction = {}

-- All atoms in the system

ATOM = {C, M, I, B, O, P, SN1, SN2, Yes, No, Garbage}

-- Some standard functions

channel dummyrun_
RUN(X_) = 
  let drun = dummyrun_ -> drun
  within drun[[dummyrun_ <- x_ | x_ <- X_]]

encrypt(m_,k_) = Encrypt.(k_,m_)
decrypt(Encrypt.(k1_,m_),k_) = if k_ == inverse(k1_) then m_ else <Garbage>
decrypt(_,_) = <Garbage>
decryptable(Encrypt.(k1_,m_),k_) = k_ == inverse(k1_) 
decryptable(_,_) = false
nth(ms_,n_) = if n_ == 1 then head(ms_) else nth(tail(ms_), n_ - 1)

-- add Garbage to a set that contains and encryption,
-- hash function application of Vernam encryption

addGarbage_(S_) =
  if S_=={} then {Garbage}
  else Union({S_, {Garbage | Encrypt._ <- S_}, 
             {Garbage | Hash._ <- S_},
             {Garbage | Xor._ <- S_}})

-- Definitions of user supplied functions

PK(arg_1_) = PK__.(arg_1_)
SK(arg_1_) = SK__.(arg_1_)
BPK(arg_1_) = BPK__.(arg_1_)
BSK(arg_1_) = BSK__.(arg_1_)

-- Inverses of functions

inverse(PK__.arg_) = SK__.arg_
inverse(SK__.arg_) = PK__.arg_
inverse(BPK__.arg_) = BSK__.arg_
inverse(BSK__.arg_) = BPK__.arg_

-- Types in system

Agent = {C, M, I}
Bank = {B}
Order = {O}
Price = {P}
SeqNo = {SN1, SN2}
Result = {Yes, No}
PublicKey = {PK(arg_1_) | arg_1_ <- Agent}
SecretKey = {SK(arg_1_) | arg_1_ <- Agent}
BankPublicKey = {BPK(arg_1_) | arg_1_ <- Bank}
BankSecretKey = {BSK(arg_1_) | arg_1_ <- Bank}


-- ************************************************************************
-- *                               Messages                               *
-- ************************************************************************

-- Message labels

datatype Labels =
  Msg1 | Msg2 | Msg3 | Msg4 | Env0 | Env2a

MSG_BODY = {ALGEBRA_M::applyRenaming(m_) | (_,m_,_,_) <- SYSTEM_M::INT_MSG_INFO}

-- Type of principals

ALL_PRINCIPALS = Union({Agent, Bank})

INTRUDER = I

HONEST = diff(ALL_PRINCIPALS, {INTRUDER})

-- Channel declarations

INPUT_MSG = SYSTEM_M::INPUT_MSG
OUTPUT_MSG = SYSTEM_M::OUTPUT_MSG
DIRECT_MSG = SYSTEM_M::DIRECT_MSG
ENV_MSG :: {(Labels, Encryption, <Encryption>)}
ENV_MSG = SYSTEM_M::ENV_MSG

channel receive: ALL_PRINCIPALS.ALL_PRINCIPALS.INPUT_MSG
channel send: ALL_PRINCIPALS.ALL_PRINCIPALS.OUTPUT_MSG
channel env : ALL_PRINCIPALS.ENV_MSG
channel error
channel start, close : HONEST.HONEST_ROLE

channel leak : addGarbage_(ALL_SECRETS)
-- Roles of agents

datatype ROLE = CUSTOMER_role | MERCHANT_role | BANK_role

HONEST_ROLE = ROLE

-- Secrets in the protocol

ALL_SECRETS_0 = Order
ALL_SECRETS = addGarbage_(ALGEBRA_M::applyRenamingToSet(ALL_SECRETS_0))

-- Define type of signals, and declare signal channel

datatype Signal = 
  Claim_Secret.ALL_PRINCIPALS.ALL_SECRETS.Set(ALL_PRINCIPALS) |
  Running1.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Bank.Order.Price |
  Commit1.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Bank.Order.Price |
  RunCom1.ALL_PRINCIPALS.ALL_PRINCIPALS.Bank.Order.Price.Bank.Order.Price |
  Running2.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price.Result |
  Commit2.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price.Result |
  RunCom2.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price.Result.Agent.Price.Result |
  Running3.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price |
  Commit3.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price |
  RunCom3.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price.Agent.Price |
  Running4.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price.Result |
  Commit4.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price.Result |
  RunCom4.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price.Result.Agent.Price.Result |
  Running5.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Bank.Order.Price |
  Commit5.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Bank.Order.Price |
  RunCom5.ALL_PRINCIPALS.ALL_PRINCIPALS.Bank.Order.Price.Bank.Order.Price |
  Running6.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price |
  Commit6.HONEST_ROLE.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price |
  RunCom6.ALL_PRINCIPALS.ALL_PRINCIPALS.Agent.Price.Agent.Price

channel signal : Signal

Fact_1 = 
  Union({
    {Garbage},
    Agent,
    Bank,
    SeqNo,
    Order,
    Price,
    Result,
    SecretKey,
    PublicKey,
    BankSecretKey,
    BankPublicKey,
    {Encrypt.(SK__.(c), <b, price, sn>) |
       b <- Bank, c <- Agent, price <- Price, sn <- SeqNo},
    {Encrypt.(BSK__.(b), <c, result>) |
       b <- Bank, c <- Agent, result <- Result}
  })

external relational_inverse_image
external relational_image
transparent chase
transparent sbisim

-- ************************************************************************
-- *                            Honest Agents                             *
-- ************************************************************************

module SYSTEM_M

  -- types of messages sent and received by agents, as they are
  -- considered by those agents

  input_proj((l_,m_,se_,re_)) = (l_,m_,re_)
  rmb_input_proj((l_,m_,se_,re_)) = ALGEBRA_M::rmb((l_,m_,re_))
  output_proj((l_,m_,se_,re_)) = (l_,m_,se_)

  INPUT_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  INPUT_INT_MSG = 
    
    Union({
      INPUT_INT_MSG1,
      INPUT_INT_MSG2,
      INPUT_INT_MSG3,
      INPUT_INT_MSG4
    })

  OUTPUT_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  OUTPUT_INT_MSG = 
    
    Union({
      OUTPUT_INT_MSG1,
      OUTPUT_INT_MSG2,
      OUTPUT_INT_MSG3,
      OUTPUT_INT_MSG4
    })

  -- A buffer between honest agents

  BUFF(in_, out_, data_, cap_) =
    let 
      in_data = {output_proj(x_) | x_ <- data_}
      BUFF_0(ms_) =
        SKIP
        []
        in_?(l_,m_,_):in_data ->
          ( if #ms_ < cap_ then BUFF_0(ms_^<(l_,m_)>) else error -> STOP )
        []
        ms_ != <> & 
          [] (l_,m_,se_,re_) : data_, (l_,m_) == head(ms_) @
            out_!ALGEBRA_M::rmb((l_,m_,re_)) -> BUFF_0(tail(ms_))
    within BUFF_0(<>)

  -- CUSTOMER

  CUSTOMER_0(c, sn) =
    [] b : Bank @ [] m : Agent @ [] order : Order @ [] price : Price @ 
      c!=m & env_I.c.(Env0, Sq.<m, b, order, price>,<>) ->
    output.c.m.(Msg1, Sq.<b, order, price, Encrypt.(SK__.(c), <b, price, sn>)>,<b, order, price>) ->
    [] result : Result @ 
      input.m.c.(Msg4, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>,<b, price, result, order>) ->
    SKIP

  CUSTOMER_1(c, sn) = 
    let -- buffering to m
        data_m = INT_MSG_INFO1
        BUFF_m :: (Encryption) -> Proc
        BUFF_m(m) = BUFF(output.c.m, receive.c.m, data_m, 1)
        alphaB_m(m) =
          {output.c.m.output_proj(x_), receive.c.m.rmb_input_proj(x_) | x_ <- data_m}
        BUFFS_m = || m : inter(HONEST, Agent) @ [alphaB_m(m)] BUFF_m(m)
        alphaBs_m = Union({alphaB_m(m) | m <- inter(HONEST, Agent)})
    within
      CUSTOMER_0(c, sn)
      [| inter({|output|}, alphaBs_m) |]
      (BUFFS_m)

  CUSTOMER(c, sn) =
    CUSTOMER_1(c, sn)
      [[input.m.c.(l_,m_,re_) <- receive.m.c.ALGEBRA_M::rmb((l_,m_,re_)) |
          m <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO4]]
      [[output.c.m.(l_,m_,se_) <- send.c.m.ALGEBRA_M::rmb((l_,m_,se_)) |
          m <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO1]]
      [[env_I.c.m_ <- env.c.ALGEBRA_M::rmb(m_) |
          m_ <- ENV_INT_MSG0]]

  -- MERCHANT

  MERCHANT_0(m) =
    [] b : Bank @ [] c : Agent @ [] order : Order @ [] price : Price @ 
    [] sig : addGarbage_({Encrypt.(SK__.(c), <b, price, sn>) | b <- Bank, c <- Agent, price <- Price, sn <- SeqNo}) @ 
      input.c.m.(Msg1, Sq.<b, order, price, sig>,<>) ->
    output.m.b.(Msg2, Sq.<c, price, sig>,<c, price>) ->
    [] result : Result @ 
    [] bsig : addGarbage_({Encrypt.(BSK__.(b), <c, result>) | b <- Bank, c <- Agent, result <- Result}) @ 
      input.b.m.(Msg3, Sq.<result, bsig>,<>) ->
    output.m.c.(Msg4, Sq.<result, bsig>,<b, order, price, result>) ->
    SKIP

  MERCHANT_1(m) = 
    let -- buffering to b
        data_b = INT_MSG_INFO2
        BUFF_b :: (Encryption) -> Proc
        BUFF_b(b) = BUFF(output.m.b, receive.m.b, data_b, 1)
        alphaB_b(b) =
          {output.m.b.output_proj(x_), receive.m.b.rmb_input_proj(x_) | x_ <- data_b}
        BUFFS_b = || b : inter(HONEST, Bank) @ [alphaB_b(b)] BUFF_b(b)
        alphaBs_b = Union({alphaB_b(b) | b <- inter(HONEST, Bank)})
        -- buffering to c
        data_c = INT_MSG_INFO4
        BUFF_c :: (Encryption) -> Proc
        BUFF_c(c) = BUFF(output.m.c, receive.m.c, data_c, 1)
        alphaB_c(c) =
          {output.m.c.output_proj(x_), receive.m.c.rmb_input_proj(x_) | x_ <- data_c}
        BUFFS_c = || c : inter(HONEST, Agent) @ [alphaB_c(c)] BUFF_c(c)
        alphaBs_c = Union({alphaB_c(c) | c <- inter(HONEST, Agent)})
    within
      MERCHANT_0(m)
      [| inter({|output|}, union(alphaBs_b, alphaBs_c)) |]
      (BUFFS_b ||| BUFFS_c)

  MERCHANT(m) =
    MERCHANT_1(m)
      [[input.c.m.(l_,m_,re_) <- receive.c.m.ALGEBRA_M::rmb((l_,m_,re_)) |
          c <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO1]]
      [[input.b.m.(l_,m_,re_) <- receive.b.m.ALGEBRA_M::rmb((l_,m_,re_)) |
          b <- Bank, (l_,m_,se_,re_) <- INT_MSG_INFO3]]
      [[output.m.b.(l_,m_,se_) <- send.m.b.ALGEBRA_M::rmb((l_,m_,se_)) |
          b <- Bank, (l_,m_,se_,re_) <- INT_MSG_INFO2]]
      [[output.m.c.(l_,m_,se_) <- send.m.c.ALGEBRA_M::rmb((l_,m_,se_)) |
          c <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO4]]

  -- BANK

  BANK_0(b) =
    [] c : Agent @ [] m : Agent @ [] price : Price @ [] sn : SeqNo @ 
      m!=c & 
      input.m.b.(Msg2, Sq.<c, price, Encrypt.(SK__.(c), <b, price, sn>)>,<>) ->
    [] result : Result @ env_I.b.(Env2a, result,<>) ->
    output.b.m.(Msg3, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>,<c, price, result>) ->
    SKIP

  BANK_1(b) = 
    let -- buffering to m
        data_m = INT_MSG_INFO3
        BUFF_m :: (Encryption) -> Proc
        BUFF_m(m) = BUFF(output.b.m, receive.b.m, data_m, 1)
        alphaB_m(m) =
          {output.b.m.output_proj(x_), receive.b.m.rmb_input_proj(x_) | x_ <- data_m}
        BUFFS_m = || m : inter(HONEST, Agent) @ [alphaB_m(m)] BUFF_m(m)
        alphaBs_m = Union({alphaB_m(m) | m <- inter(HONEST, Agent)})
    within
      BANK_0(b)
      [| inter({|output|}, alphaBs_m) |]
      (BUFFS_m)

  BANK(b) =
    BANK_1(b)
      [[input.m.b.(l_,m_,re_) <- receive.m.b.ALGEBRA_M::rmb((l_,m_,re_)) |
          m <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO2]]
      [[output.b.m.(l_,m_,se_) <- send.b.m.ALGEBRA_M::rmb((l_,m_,se_)) |
          m <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO3]]
      [[env_I.b.m_ <- env.b.ALGEBRA_M::rmb(m_) |
          m_ <- ENV_INT_MSG2a]]

  -- Process representing C

  Alpha_CUSTOMER_C = 
    Union({
      {|env.C.m_ | m_ <- ENV_MSG0|},
      {|send.C.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG1|},
      {|receive.C.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG1|},
      {|receive.A_.C.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG4|}
    })

  CUSTOMER_C = ((CUSTOMER(C, SN1) ; STOP)
    |||
    (CUSTOMER(C, SN2) ; STOP))

  Alpha_C = 
    Union({
      {|env.C|},
      {|send.C.A_ | A_ <- ALL_PRINCIPALS|},
      {|receive.C.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG1|},
      {|receive.C.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2|},
      {|receive.C.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG3|},
      {|receive.C.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG4|},
      {|receive.A_.C.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG4|}
    })

  CBlockSet =
    let self_comms = {|receive.C.C.m_ | m_ <- Union({INPUT_MSG1, INPUT_MSG2, INPUT_MSG3, INPUT_MSG4})
|}
        Alpha_CUSTOMER_C_receive = 
          inter(self_comms, Alpha_CUSTOMER_C)
      allowSet = {}
    within diff(self_comms, allowSet)

  AGENT_C =
    (CUSTOMER_C [Alpha_CUSTOMER_C || {} ] STOP)
      [| CBlockSet |] STOP

  -- Process representing M

  Alpha_MERCHANT_M = 
    Union({
      {|send.M.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG2|},
      {|send.M.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG4|},
      {|receive.M.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2|},
      {|receive.M.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG4|},
      {|receive.A_.M.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG1|},
      {|receive.A_.M.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG3|}
    })

  MERCHANT_M = (MERCHANT(M) ; STOP)

  Alpha_M = 
    Union({
      {|env.M|},
      {|send.M.A_ | A_ <- ALL_PRINCIPALS|},
      {|receive.M.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG1|},
      {|receive.M.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2|},
      {|receive.M.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG3|},
      {|receive.M.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG4|},
      {|receive.A_.M.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG1|},
      {|receive.A_.M.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG3|}
    })

  MBlockSet =
    let self_comms = {|receive.M.M.m_ | m_ <- Union({INPUT_MSG1, INPUT_MSG2, INPUT_MSG3, INPUT_MSG4})
|}
        Alpha_MERCHANT_M_receive = 
          inter(self_comms, Alpha_MERCHANT_M)
      allowSet = {}
    within diff(self_comms, allowSet)

  AGENT_M =
    (MERCHANT_M [Alpha_MERCHANT_M || {} ] STOP)
      [| MBlockSet |] STOP

  -- Process representing B

  Alpha_BANK_B = 
    Union({
      {|env.B.m_ | m_ <- ENV_MSG2a|},
      {|send.B.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG3|},
      {|receive.B.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG3|},
      {|receive.A_.B.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2|}
    })

  BANK_B = ((BANK(B) ; STOP)
    |||
    (BANK(B) ; STOP))

  Alpha_B = 
    Union({
      {|env.B|},
      {|send.B.A_ | A_ <- ALL_PRINCIPALS|},
      {|receive.B.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG1|},
      {|receive.B.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2|},
      {|receive.B.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG3|},
      {|receive.B.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG4|},
      {|receive.A_.B.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG2|}
    })

  BBlockSet =
    let self_comms = {|receive.B.B.m_ | m_ <- Union({INPUT_MSG1, INPUT_MSG2, INPUT_MSG3, INPUT_MSG4})
|}
        Alpha_BANK_B_receive = 
          inter(self_comms, Alpha_BANK_B)
      allowSet = {}
    within diff(self_comms, allowSet)

  AGENT_B =
    (BANK_B [Alpha_BANK_B || {} ] STOP)
      [| BBlockSet |] STOP

exports

  -- Messages as they appear on the network; each messages is renamed
  -- (by rmb) to the representative member of its equivalence class

  INPUT_MSG1 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG1}
  INPUT_MSG2 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG2}
  INPUT_MSG3 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG3}
  INPUT_MSG4 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG4}

  OUTPUT_MSG1 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG1}
  OUTPUT_MSG2 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG2}
  OUTPUT_MSG3 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG3}
  OUTPUT_MSG4 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG4}

  DIRECT_MSG1 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO1}
  DIRECT_MSG2 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO2}
  DIRECT_MSG3 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO3}
  DIRECT_MSG4 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO4}

  -- Environmental messages

  ENV_INT_MSG0 :: {(Labels, Encryption, <Encryption>)}
  ENV_INT_MSG0 = 
    {(Env0, Sq.<m, b, order, price>, <>) |
       b <- Bank, m <- Agent, order <- Order, price <- Price}
  ENV_INT_MSG2a :: {(Labels, Encryption, <Encryption>)}
  ENV_INT_MSG2a = 
    {(Env2a, result, <>) |
       result <- Result}

  ENV_MSG0 = {ALGEBRA_M::rmb(m_) | m_ <- ENV_INT_MSG0}
  ENV_MSG2a = {ALGEBRA_M::rmb(m_) | m_ <- ENV_INT_MSG2a}

  ENV_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  ENV_INT_MSG = Union({ENV_INT_MSG0, ENV_INT_MSG2a})

  -- information about messages sent and received by agents, including
  -- extras fields for both agents

  INT_MSG_INFO1 = 
    {(Msg1, Sq.<b, order, price, sig>, <b, order, price>, <>) |
       b <- Bank, order <- Order, price <- Price, 
       sig <- addGarbage_({Encrypt.(SK__.(c), <b, price, sn>) | b <- Bank, c <- Agent, price <- Price, sn <- SeqNo})}
  INT_MSG_INFO2 = 
    {(Msg2, Sq.<c, price, sig>, <c, price>, <>) |
       c <- Agent, price <- Price, 
       sig <- addGarbage_({Encrypt.(SK__.(c), <b, price, sn>) | b <- Bank, c <- Agent, price <- Price, sn <- SeqNo})}
  INT_MSG_INFO3 = 
    {(Msg3, Sq.<result, bsig>, <c, price, result>, <>) |
       c <- Agent, price <- Price, result <- Result, 
       bsig <- addGarbage_({Encrypt.(BSK__.(b), <c, result>) | b <- Bank, c <- Agent, result <- Result})}
  INT_MSG_INFO4 = 
    {(Msg4, Sq.<result, bsig>, <b, order, price, result>, <b, price_X_, result, order_X_>) |
       b <- Bank, order <- Order, price <- Price, result <- Result, 
       price_X_ <- Price, order_X_ <- Order, 
       bsig <- addGarbage_({Encrypt.(BSK__.(b), <c, result>) | b <- Bank, c <- Agent, result <- Result})}

  ENV_MSG = {ALGEBRA_M::rmb(m_) | m_ <- ENV_INT_MSG}

  INT_MSG_INFO :: {(Labels, Encryption, <Encryption>, <Encryption>)}
  INT_MSG_INFO = 
    Union({
      INT_MSG_INFO1,
      INT_MSG_INFO2,
      INT_MSG_INFO3,
      INT_MSG_INFO4
    })
  INPUT_INT_MSG1 = { input_proj(mt_) | mt_ <- INT_MSG_INFO1 }
  INPUT_INT_MSG2 = { input_proj(mt_) | mt_ <- INT_MSG_INFO2 }
  INPUT_INT_MSG3 = { input_proj(mt_) | mt_ <- INT_MSG_INFO3 }
  INPUT_INT_MSG4 = { input_proj(mt_) | mt_ <- INT_MSG_INFO4 }

  INPUT_MSG = Union({INPUT_MSG1, INPUT_MSG2, INPUT_MSG3, INPUT_MSG4})
  OUTPUT_INT_MSG1 = { output_proj(mt_) | mt_ <- INT_MSG_INFO1 }
  OUTPUT_INT_MSG2 = { output_proj(mt_) | mt_ <- INT_MSG_INFO2 }
  OUTPUT_INT_MSG3 = { output_proj(mt_) | mt_ <- INT_MSG_INFO3 }
  OUTPUT_INT_MSG4 = { output_proj(mt_) | mt_ <- INT_MSG_INFO4 }

  OUTPUT_MSG = 
    Union({
      OUTPUT_MSG1,
      OUTPUT_MSG2,
      OUTPUT_MSG3,
      OUTPUT_MSG4
    })
  DIRECT_MSG = Union({DIRECT_MSG1, DIRECT_MSG2, DIRECT_MSG3, DIRECT_MSG4})

  channel input:ALL_PRINCIPALS.ALL_PRINCIPALS.INPUT_INT_MSG
  channel output: ALL_PRINCIPALS.ALL_PRINCIPALS.OUTPUT_INT_MSG
  channel env_I : ALL_PRINCIPALS.ENV_INT_MSG

  -- Complete system

  SYSTEM_0 =
    (AGENT_C
      [Alpha_C||union(Alpha_M, Alpha_B)]
    (AGENT_M
      [Alpha_M||Alpha_B]
    AGENT_B))

endmodule

-- ************************************************************************
-- *                               Algebra                                *
-- ************************************************************************

module ALGEBRA_M

  -- Algebraic laws, defined as a set of pairs

  laws = {(Garbage, Garbage)}

  -- Calculate transitive closure of algebraic laws, and select
  -- representative member of each equivalence class

  external mtransclose
  renaming = mtransclose(laws, Fact_1)
  ren = relational_inverse_image(renaming)

  -- function that renames non-sequential fact to representative member

  applyRenaming0(a_) =
    let S_ = ren(a_)
    within if card(S_)==0 then a_ else elsing(S_)

  elsing({x_}) = x_

  domain = {a_ | (_,a_) <- renaming}

exports

  -- function that renames arbitrary fact to representative member

  applyRenaming(Sq.ms_) =
    if member(Sq.ms_, Fact_1) then applyRenaming0(Sq.ms_) 
    else Sq.<applyRenaming0(m_) | m_ <- ms_>
  applyRenaming(a_) = applyRenaming0(a_)

  -- function that renames (label, fact, extras) triples

  rmb((l_,m_,extras_)) = 
    (l_, applyRenaming(m_), applyRenamingToSeq(extras_))
  rmb4((l_,m_,s_extras_,r_extras_)) = 
    (l_, applyRenaming(m_), applyRenamingToSeq(s_extras_), 
     applyRenamingToSeq(r_extras_))

  -- lift renaming to sets and to deductions

  applyRenamingToSet(X_) =
    union({elsing(ren(a_)) | a_ <- inter(X_,domain)},  diff(X_, domain))

  applyRenamingToSeq(X_) = <applyRenaming(e_) | e_ <- X_>

  applyRenamingToDeductions(S_) =
    {(applyRenaming0(f_), applyRenamingToSet(X_)) | (f_,X_) <- S_}

endmodule

-- ************************************************************************
-- *                             The Intruder                             *
-- ************************************************************************

module INTRUDER_M

  -- Intruder's deductions

  unSq_ (Sq.ms_) = set(ms_)
  unSq_ (m_) = {m_}

  unknown_(S_) = diff(S_, IK0)

  Base_Deductions_ =
    Union({SqDeductions, UnSqDeductions, 
           EncryptionDeductions, DecryptionDeductions,
           VernEncDeductions, VernDecDeductions, 
           FnAppDeductions, HashDeductions, UserDeductions})

  SqDeductions =
    {(Sq.fs_, unknown_(set(fs_))) | Sq.fs_ <- Fact_1}

  UnSqDeductions =
    {(f_, unknown_({Sq.fs_})) | Sq.fs_ <- Fact_1, f_ <- unknown_(set(fs_))}

  EncryptionDeductions =
    {(Encrypt.(k_,fs_), unknown_(union({k_}, set(fs_)))) | 
        Encrypt.(k_,fs_) <- Fact_1}

  DecryptionDeductions =
    {(f_, unknown_({Encrypt.(k_,fs_), inverse(k_)})) |
        Encrypt.(k_,fs_) <- Fact_1, f_ <- unknown_(set(fs_))}

  VernEncDeductions =
    {(Xor.(m1_,m2_), unknown_(union(unSq_(m1_), unSq_(m2_)))) | 
        Xor.(m1_,m2_) <- Fact_1}

  VernDecDeductions =
      {(m11_, union(unknown_(unSq_(m2_)), {Xor.(m1_,m2_)})) | 
         Xor.(m1_,m2_) <- Fact_1, m11_ <- unSq_(m1_)}

  HashDeductions = {(Hash.(f_, ms_), set(ms_)) | Hash.(f_, ms_) <- Fact_1}

  UserDeductions = {}

  FnAppDeductions = 
    {(PK__.arg_1_, unknown_({arg_1_})) |
        PK__.arg_1_ <- Fact_1}

  -- close up intruder's initial knowledge under deductions;
  -- calculate which facts cannot be learnt

  components_(Sq.ms_) = 
    if member(Sq.ms_, Fact_1) then {Sq.ms_} else set(ms_)
  components_(m_) = {m_}

  Seeable_ = 
    Union({unknown_(components_(m_)) | (_,m_,_,_) <- SYSTEM_M::INT_MSG_INFO})

  (IK1, Deductions_, KnowableFact_) = 
    Close_(ALGEBRA_M::applyRenamingToSet(IK0), 
           ALGEBRA_M::applyRenamingToDeductions(Base_Deductions), 
           ALGEBRA_M::applyRenamingToSet(Fact_1))

  LearnableFact = diff(KnowableFact, IK1)

  -- The intruder

  -- * leak is used to signal that a possible secret has been learnt
  -- * hear and say are used to represent hearing or saying a message
  -- * infer(f,fs) represent deducing fact f from the set of facts fs

  -- Component of intruder for currently unknown fact f_:
  -- * ms_ is the set of messages that contain f_ at the top level
  -- * fss_ is the set of sets of facts from which f_ can be deduced
  -- * ds_ is the set of deductions that use f_

  IGNORANT(f_,ms_,fss_,ds_) =
    hear?m_:ms_ -> KNOWS(f_,ms_,ds_)
    []
    ([] fs_ : fss_, not(member(f_,fs_)) @ 
        infer.(f_,fs_) -> KNOWS(f_,ms_,ds_))

  -- Component of intruder for known fact f_

  KNOWS(f_,ms_,ds_) =
    hear?m_:ms_ -> KNOWS(f_,ms_,ds_)
    []
    say?m_:ms_ -> KNOWS(f_,ms_,ds_)
    [] 
    ([] ded@@(f1_,fs_) : ds_, f1_!=f_ @ infer.ded -> KNOWS(f_,ms_,ds_))
    []
    member(f_,ALL_SECRETS) & leak.f_ -> KNOWS(f_,ms_,ds_)

  -- Alphabet of this component

  AlphaL(f_,ms_,fss_,ds_) =
    Union({(if member(f_,ALL_SECRETS) then {leak.f_} else {}),
           {hear.m_, say.m_ | m_ <- ms_},
           {infer.(f_,fs_) | fs_ <- fss_},
           {infer.(f1_,fs_) | (f1_,fs_) <- ds_}
         })

  -- Set of all (f_, ms_, fss_, ds_) for which intruder components 
  -- must be built

  f_ms_fss_ds_s(Deductions,LearnableFact) = 
    let rid_ = relational_image(Deductions)
        msf_ = relational_image({(f_, m_) | m_ <- MSG_BODY, f_ <- unSq_(m_)})
        xsf_ = relational_image({(f_, x_) | x_@@(_,fs_) <- Deductions,
                                            f_ <- fs_})
    within {(f_, msf_(f_), rid_(f_), xsf_(f_)) | f_ <- LearnableFact}

  -- Rename events appropriately

  BUILD_INTRUDER_0(INTRUDER_0) =
    ((chase(INTRUDER_0)
      [[ hear.m_ <- hear.m_, hear.m_ <- send.A_.I.(l_,m_,se_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2,
           SYSTEM_M::DIRECT_MSG3,
           SYSTEM_M::DIRECT_MSG4
         }), 
         A_ <- diff(SenderType(l_),{I}) ]] 
     [|{| hear |}|] STOP)
      [[ say.m_ <- say.m_, say.m_ <- receive.I.B_.(l_,m_,re_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2,
           SYSTEM_M::DIRECT_MSG3,
           SYSTEM_M::DIRECT_MSG4
         }), 
         B_ <- ReceiverType(l_) ]] 
     [|{| say |}|] STOP)

  -- Add in facts that are known initially

  SAY_KNOWN_0(IK1) = 
    (inter(IK1, ALL_SECRETS) != {} & dummy_leak -> SAY_KNOWN_0(IK1)) 
    [] dummy_send -> SAY_KNOWN_0(IK1) 
    [] dummy_receive -> SAY_KNOWN_0(IK1) 

  SAY_KNOWN(IK1) =
    SAY_KNOWN_0(IK1)
      [[ dummy_leak <- leak.f_ | f_ <- inter(IK1, ALL_SECRETS) ]]
      [[ dummy_send <- dummy_send, dummy_send <- send.A_.I.(l_,m_,se_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2,
           SYSTEM_M::DIRECT_MSG3,
           SYSTEM_M::DIRECT_MSG4
         }), components_(m_) <= IK1, 
         A_ <- diff(SenderType(l_),{I}) ]] 
      [[ dummy_receive <- dummy_receive, dummy_receive <- receive.I.B_.(l_,m_,re_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2,
           SYSTEM_M::DIRECT_MSG3,
           SYSTEM_M::DIRECT_MSG4
         }), components_(m_) <= IK1, 
         B_ <- ReceiverType(l_) ]] 
  STOP_SET = { dummy_send, dummy_receive }

exports

  -- Types of sender and receiver of each message

  SenderType (Msg1) = Agent
  SenderType (Msg2) = Agent
  SenderType (Msg3) = Bank
  SenderType (Msg4) = Agent

  ReceiverType(Msg1) = Agent
  ReceiverType(Msg2) = Bank
  ReceiverType(Msg3) = Agent
  ReceiverType(Msg4) = Agent

  -- Intruder's initial knowledge

  IK0 = {I, C, M, B, O, P, Yes, No, SK__.(I), SN1, Garbage}

  Deductions = Deductions_

  Base_Deductions = Base_Deductions_

  Close_(IK_, ded_, fact_) =
    CloseButNotFacts_(IK_, ded_, fact_, { })

  -- The method below is used to calculate IK1 and Deductions and is important
  -- when temporal checks are being done. If no check was done on f being
  -- in Facts then the infer event corresponding to a intruder send event may be hidden.
  CloseButNotFacts_(IK_, ded_, fact_, excludedFacts_) =
    let IK1_ = 
          union(IK_, {f_ | (f_,fs_) <- ded_, fs_ <= IK_ and not member(f_,excludedFacts_)})
        ded1_ = 
          {(f_,fs_) | (f_,fs_) <- ded_, not (member(f_,IK_)),
                      fs_ <= fact_}
        fact1_ = Union({IK_, {f_ | (f_,fs_) <- ded_}, Seeable_})
    within
    if card(IK_)==card(IK1_) and card(ded_)==card(ded1_)
       and card(fact_)==card(fact1_)
    then (IK_, {(f_,diff(fs_,IK_)) | (f_,fs_) <- ded_}, fact_)
    else Close_(IK1_, ded1_, fact1_)

KnowableFact = KnowableFact_ 
  -- Put components together in parallel
  INTRUDER_00(Deductions,LearnableFact) = 
    (|| (f_,ms_,fss_,ds_) : f_ms_fss_ds_s(Deductions,LearnableFact) @ 
         [AlphaL(f_,ms_,fss_,ds_)] IGNORANT(f_,ms_,fss_,ds_))

  INTRUDER_0 = INTRUDER_00(Deductions, LearnableFact) \ {|infer|}

  -- Set of all deductions that could occur
  COMBINED_DEDUCTIONS =
    let ds_ = INTRUDER_M::Deductions
    within -- Don't you hate hacks like this (FDR does not allow empty channel types)?
      if ds_ == {} then {(Garbage, {Garbage})} else ds_

  -- Declare channels:
  channel hear, say : MSG_BODY
  channel dummy_leak, dummy_send, dummy_receive

  -- Complete intruder

  -- Intruder used for temporal specs
  BUILD_INTRUDER'(INTRUDER_0,IK) =
    (BUILD_INTRUDER_0(INTRUDER_0) ||| SAY_KNOWN(IK)) [| STOP_SET |] STOP

  -- Intruder used for all other specs
  BUILD_INTRUDER(INTRUDER_0) = BUILD_INTRUDER'(INTRUDER_0,IK1)

endmodule

-- FDR bug: cannot have a module prefix in a channel type
Deductions' = INTRUDER_M::COMBINED_DEDUCTIONS
channel infer : Deductions'

IntruderInterface = 
  Union({
    {| receive.I.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- Union({
      SYSTEM_M::INPUT_MSG1,
      SYSTEM_M::INPUT_MSG2,
      SYSTEM_M::INPUT_MSG3,
      SYSTEM_M::INPUT_MSG4
    }) |},
    {| receive.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.I.m_ | A_ <- ALL_PRINCIPALS, m_ <- Union({
      SYSTEM_M::OUTPUT_MSG1,
      SYSTEM_M::OUTPUT_MSG2,
      SYSTEM_M::OUTPUT_MSG3,
      SYSTEM_M::OUTPUT_MSG4
    }) |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- {} |}
  })

SYSTEM = 
  SYSTEM_M::SYSTEM_0 [| IntruderInterface |] INTRUDER_M::BUILD_INTRUDER(INTRUDER_M::INTRUDER_0)

-- ************************************************************************
-- *                    Specifications and Assertions                     *
-- ************************************************************************

module SECRET_M

  -- Specification for single secret

  SECRET_SPEC_0(s_) = 
    signal.Claim_Secret?A_!s_?Bs_ ->
      (if member(I, Bs_) then SECRET_SPEC_0(s_)
       else SECRET_SPEC_1(s_))
    []
    leak.s_ -> SECRET_SPEC_0(s_)
  SECRET_SPEC_1(s_) = 
    signal.Claim_Secret?A_!s_?Bs_ -> SECRET_SPEC_1(s_)
  -- Specification for all secrets

  AlphaS(s_) = 
    Union({
      {|signal.Claim_Secret.A_.s_ | A_ <- ALL_PRINCIPALS|},
      {leak.s_}
    })
  -- Sequential version; secs_ is secrets that intruder must not learn

  SEQ_SECRET_SPEC_0(secs_) =
    scs?s_!IntIn -> SEQ_SECRET_SPEC_0(secs_)
    []
    card(secs_)<3 & scs?s_!IntNotIn ->
      SEQ_SECRET_SPEC_0(union(secs_,{s_}))
    []
    card(secs_)==3 & scs?s_:secs_!IntNotIn ->
      SEQ_SECRET_SPEC_0(secs_)
    []
    leak?s_ : diff(ALL_SECRETS,secs_) -> SEQ_SECRET_SPEC_0(secs_)

  isIntIn(S_) = if member(I,S_) then IntIn else IntNotIn

  Alpha_SECRETS =
    Union({
      {|leak, signal.Claim_Secret.A_ | A_ <- HONEST|}
    })

  Alpha_SEQ_SECRETS = 
    Union({
      {|leak, scs|}
    })

exports

  SECRET_SPEC = (|| s_ : ALL_SECRETS @ [AlphaS(s_)] SECRET_SPEC_0(s_))

  datatype IncInt = IntIn | IntNotIn

  channel scs : ALL_SECRETS.IncInt

  SEQ_SECRET_SPEC = SEQ_SECRET_SPEC_0({})

  -- System for secrecy checking

  SYSTEM_S = 
    let Agent_renamed_ = ALGEBRA_M::applyRenamingToSet(Agent)
        Bank_renamed_ = ALGEBRA_M::applyRenamingToSet(Bank)
        Price_renamed_ = ALGEBRA_M::applyRenamingToSet(Price)
        Result_renamed_ = ALGEBRA_M::applyRenamingToSet(Result)
        Order_renamed_ = ALGEBRA_M::applyRenamingToSet(Order)
    within
    SYSTEM
      [[receive.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>, <b, price, result, order>))
          <- signal.Claim_Secret.c.ALGEBRA_M::applyRenaming(order).{m}, 
        send.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, bsig>, <b, order, price, result>))
          <- signal.Claim_Secret.m.ALGEBRA_M::applyRenaming(order).{c} |
            bsig <- ALGEBRA_M::applyRenamingToSet(addGarbage_({Encrypt.(BSK__.(b), <c, result>) | b <- Bank, c <- Agent, result <- Result})), 
            m <- Agent_renamed_, c <- Agent_renamed_, b <- Bank_renamed_, 
            price <- Price_renamed_, result <- Result_renamed_, 
            order <- Order_renamed_
      ]] \ {| env, send, receive |}

  SYSTEM_S_SEQ =
    let Agent_renamed_ = ALGEBRA_M::applyRenamingToSet(Agent)
        Bank_renamed_ = ALGEBRA_M::applyRenamingToSet(Bank)
        Price_renamed_ = ALGEBRA_M::applyRenamingToSet(Price)
        Result_renamed_ = ALGEBRA_M::applyRenamingToSet(Result)
        Order_renamed_ = ALGEBRA_M::applyRenamingToSet(Order)
    within
    SYSTEM
      [[receive.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>, <b, price, result, order>))
          <- scs.ALGEBRA_M::applyRenaming(order).isIntIn({c, m}), 
        send.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, bsig>, <b, order, price, result>))
          <- scs.ALGEBRA_M::applyRenaming(order).isIntIn({m, c}) |
            bsig <- ALGEBRA_M::applyRenamingToSet(addGarbage_({Encrypt.(BSK__.(b), <c, result>) | b <- Bank, c <- Agent, result <- Result})), 
            m <- Agent_renamed_, c <- Agent_renamed_, b <- Bank_renamed_, 
            price <- Price_renamed_, result <- Result_renamed_, 
            order <- Order_renamed_
      ]] \ {| env, send, receive |}

endmodule

-- Assertion of secrecy

assert SECRET_M::SECRET_SPEC [T= SECRET_M::SYSTEM_S
assert SECRET_M::SEQ_SECRET_SPEC [T= SECRET_M::SYSTEM_S_SEQ

-- ************************************************************************
-- *                 Authentication specification number 1                *
-- ************************************************************************

module AUTH1_M

  -- Spec parameterized by name of agent being authenticated

  AuthenticateCUSTOMERToMERCHANTAgreement_b_order_price_0(c) =
    signal.Running1.CUSTOMER_role.c?m?b?order?price ->
    signal.Commit1.MERCHANT_role.m.c.b.order.price -> STOP

  AlphaAuthenticateCUSTOMERToMERCHANTAgreement_b_order_price_0(c) =
    {|signal.Running1.CUSTOMER_role.c.m,
      signal.Commit1.MERCHANT_role.m.c |
         m <- inter(Agent, HONEST)|}

  -- Specs for particular agents being authenticated

  AuthenticateCUSTOMERCToMERCHANTAgreement_b_order_price =
    AuthenticateCUSTOMERToMERCHANTAgreement_b_order_price_0(C)
  |||
  AuthenticateCUSTOMERToMERCHANTAgreement_b_order_price_0(C)

  AuthenticateCUSTOMERMToMERCHANTAgreement_b_order_price =
    STOP

  -- alphabet of specification

  alphaAuthenticateCUSTOMERToMERCHANTAgreement_b_order_price =
    Union({
      AlphaAuthenticateCUSTOMERToMERCHANTAgreement_b_order_price_0(C),
      AlphaAuthenticateCUSTOMERToMERCHANTAgreement_b_order_price_0(M)
    })

exports

  -- Specs for all agents being authenticated

  AuthenticateCUSTOMERToMERCHANTAgreement_b_order_price =
    (AuthenticateCUSTOMERCToMERCHANTAgreement_b_order_price
    [| inter(AlphaAuthenticateCUSTOMERToMERCHANTAgreement_b_order_price_0(C),
             AlphaAuthenticateCUSTOMERToMERCHANTAgreement_b_order_price_0(M)) |]
    AuthenticateCUSTOMERMToMERCHANTAgreement_b_order_price)

  -- System for authentication checking

  SYSTEM_1 =
    let Agent_renamed_ = ALGEBRA_M::applyRenamingToSet(Agent)
        Bank_renamed_ = ALGEBRA_M::applyRenamingToSet(Bank)
        Order_renamed_ = ALGEBRA_M::applyRenamingToSet(Order)
        Price_renamed_ = ALGEBRA_M::applyRenamingToSet(Price)
        SeqNo_renamed_ = ALGEBRA_M::applyRenamingToSet(SeqNo)
        Result_renamed_ = ALGEBRA_M::applyRenamingToSet(Result)
    within
      SYSTEM
       [[send.c.m.ALGEBRA_M::rmb((Msg1, Sq.<b, order, price, Encrypt.(SK__.(c), <b, price, sn>)>, <b, order, price>)) <-
          signal.Running1.CUSTOMER_role.c.m.b.order.price,  
        send.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, bsig>, <b, order, price, result>)) <-
          signal.Commit1.MERCHANT_role.m.c.b.order.price |
            c <- Agent_renamed_, m <- Agent_renamed_, b <- Bank_renamed_, 
            order <- Order_renamed_, price <- Price_renamed_, 
            sn <- SeqNo_renamed_, result <- Result_renamed_, 
            bsig <- ALGEBRA_M::applyRenamingToSet(addGarbage_({Encrypt.(BSK__.(b), <c, result>) | b <- Bank, c <- Agent, result <- Result}))
      ]]
      \ diff(Events, alphaAuthenticateCUSTOMERToMERCHANTAgreement_b_order_price)

endmodule

assert AUTH1_M::AuthenticateCUSTOMERToMERCHANTAgreement_b_order_price [T= 
       AUTH1_M::SYSTEM_1

-- ************************************************************************
-- *                 Authentication specification number 2                *
-- ************************************************************************

module AUTH2_M

  -- Spec parameterized by name of agent being authenticated

  AuthenticateBANKToMERCHANTAgreement_c_price_result_0(b) =
    signal.Running2.BANK_role.b?m?c?price?result ->
    signal.Commit2.MERCHANT_role.m.b.c.price.result -> STOP

  AlphaAuthenticateBANKToMERCHANTAgreement_c_price_result_0(b) =
    {|signal.Running2.BANK_role.b.m,
      signal.Commit2.MERCHANT_role.m.b |
         m <- inter(Agent, HONEST)|}

  -- Specs for particular agents being authenticated

  AuthenticateBANKBToMERCHANTAgreement_c_price_result =
    AuthenticateBANKToMERCHANTAgreement_c_price_result_0(B)
  |||
  AuthenticateBANKToMERCHANTAgreement_c_price_result_0(B)

  -- alphabet of specification

  alphaAuthenticateBANKToMERCHANTAgreement_c_price_result =
    AlphaAuthenticateBANKToMERCHANTAgreement_c_price_result_0(B)

exports

  -- Specs for all agents being authenticated

  AuthenticateBANKToMERCHANTAgreement_c_price_result =
    AuthenticateBANKBToMERCHANTAgreement_c_price_result

  -- System for authentication checking

  SYSTEM_2 =
    let Bank_renamed_ = ALGEBRA_M::applyRenamingToSet(Bank)
        Agent_renamed_ = ALGEBRA_M::applyRenamingToSet(Agent)
        Price_renamed_ = ALGEBRA_M::applyRenamingToSet(Price)
        Result_renamed_ = ALGEBRA_M::applyRenamingToSet(Result)
        Order_renamed_ = ALGEBRA_M::applyRenamingToSet(Order)
    within
      SYSTEM
       [[send.b.m.ALGEBRA_M::rmb((Msg3, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>, <c, price, result>)) <-
          signal.Running2.BANK_role.b.m.c.price.result,  
        send.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, bsig>, <b, order, price, result>)) <-
          signal.Commit2.MERCHANT_role.m.b.c.price.result |
            b <- Bank_renamed_, m <- Agent_renamed_, c <- Agent_renamed_, 
            price <- Price_renamed_, result <- Result_renamed_, 
            order <- Order_renamed_, 
            bsig <- ALGEBRA_M::applyRenamingToSet(addGarbage_({Encrypt.(BSK__.(b), <c, result>) | b <- Bank, c <- Agent, result <- Result}))
      ]]
      \ diff(Events, alphaAuthenticateBANKToMERCHANTAgreement_c_price_result)

endmodule

assert AUTH2_M::AuthenticateBANKToMERCHANTAgreement_c_price_result [T= 
       AUTH2_M::SYSTEM_2

-- ************************************************************************
-- *                 Authentication specification number 3                *
-- ************************************************************************

module AUTH3_M

  -- Spec parameterized by name of agent being authenticated

  AuthenticateCUSTOMERToBANKAgreement_m_price_0(c) =
    signal.Running3.CUSTOMER_role.c?b?m?price ->
    signal.Commit3.BANK_role.b.c.m.price -> STOP

  AlphaAuthenticateCUSTOMERToBANKAgreement_m_price_0(c) =
    {|signal.Running3.CUSTOMER_role.c.b,
      signal.Commit3.BANK_role.b.c |
         b <- inter(Bank, HONEST)|}

  -- Specs for particular agents being authenticated

  AuthenticateCUSTOMERCToBANKAgreement_m_price =
    AuthenticateCUSTOMERToBANKAgreement_m_price_0(C)
  |||
  AuthenticateCUSTOMERToBANKAgreement_m_price_0(C)

  AuthenticateCUSTOMERMToBANKAgreement_m_price =
    STOP

  -- alphabet of specification

  alphaAuthenticateCUSTOMERToBANKAgreement_m_price =
    Union({
      AlphaAuthenticateCUSTOMERToBANKAgreement_m_price_0(C),
      AlphaAuthenticateCUSTOMERToBANKAgreement_m_price_0(M)
    })

exports

  -- Specs for all agents being authenticated

  AuthenticateCUSTOMERToBANKAgreement_m_price =
    (AuthenticateCUSTOMERCToBANKAgreement_m_price
    [| inter(AlphaAuthenticateCUSTOMERToBANKAgreement_m_price_0(C),
             AlphaAuthenticateCUSTOMERToBANKAgreement_m_price_0(M)) |]
    AuthenticateCUSTOMERMToBANKAgreement_m_price)

  -- System for authentication checking

  SYSTEM_3 =
    let Agent_renamed_ = ALGEBRA_M::applyRenamingToSet(Agent)
        Bank_renamed_ = ALGEBRA_M::applyRenamingToSet(Bank)
        Order_renamed_ = ALGEBRA_M::applyRenamingToSet(Order)
        Price_renamed_ = ALGEBRA_M::applyRenamingToSet(Price)
        SeqNo_renamed_ = ALGEBRA_M::applyRenamingToSet(SeqNo)
        Result_renamed_ = ALGEBRA_M::applyRenamingToSet(Result)
    within
      SYSTEM
       [[send.c.m.ALGEBRA_M::rmb((Msg1, Sq.<b, order, price, Encrypt.(SK__.(c), <b, price, sn>)>, <b, order, price>)) <-
          signal.Running3.CUSTOMER_role.c.b.m.price,  
        send.b.m.ALGEBRA_M::rmb((Msg3, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>, <c, price, result>)) <-
          signal.Commit3.BANK_role.b.c.m.price |
            c <- Agent_renamed_, m <- Agent_renamed_, b <- Bank_renamed_, 
            order <- Order_renamed_, price <- Price_renamed_, 
            sn <- SeqNo_renamed_, result <- Result_renamed_
      ]]
      \ diff(Events, alphaAuthenticateCUSTOMERToBANKAgreement_m_price)

endmodule

assert AUTH3_M::AuthenticateCUSTOMERToBANKAgreement_m_price [T= 
       AUTH3_M::SYSTEM_3

-- ************************************************************************
-- *                 Authentication specification number 4                *
-- ************************************************************************

module AUTH4_M

  -- Spec parameterized by name of agent being authenticated

  AuthenticateBANKToCUSTOMERAgreement_m_price_result_0(b) =
    signal.Running4.BANK_role.b?c?m?price?result ->
    signal.Commit4.CUSTOMER_role.c.b.m.price.result -> STOP

  AlphaAuthenticateBANKToCUSTOMERAgreement_m_price_result_0(b) =
    {|signal.Running4.BANK_role.b.c,
      signal.Commit4.CUSTOMER_role.c.b |
         c <- inter(Agent, HONEST)|}

  -- Specs for particular agents being authenticated

  AuthenticateBANKBToCUSTOMERAgreement_m_price_result =
    AuthenticateBANKToCUSTOMERAgreement_m_price_result_0(B)
  |||
  AuthenticateBANKToCUSTOMERAgreement_m_price_result_0(B)

  -- alphabet of specification

  alphaAuthenticateBANKToCUSTOMERAgreement_m_price_result =
    AlphaAuthenticateBANKToCUSTOMERAgreement_m_price_result_0(B)

exports

  -- Specs for all agents being authenticated

  AuthenticateBANKToCUSTOMERAgreement_m_price_result =
    AuthenticateBANKBToCUSTOMERAgreement_m_price_result

  -- System for authentication checking

  SYSTEM_4 =
    let Bank_renamed_ = ALGEBRA_M::applyRenamingToSet(Bank)
        Agent_renamed_ = ALGEBRA_M::applyRenamingToSet(Agent)
        Price_renamed_ = ALGEBRA_M::applyRenamingToSet(Price)
        Result_renamed_ = ALGEBRA_M::applyRenamingToSet(Result)
        Order_renamed_ = ALGEBRA_M::applyRenamingToSet(Order)
    within
      SYSTEM
       [[send.b.m.ALGEBRA_M::rmb((Msg3, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>, <c, price, result>)) <-
          signal.Running4.BANK_role.b.c.m.price.result,  
        receive.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>, <b, price, result, order>)) <-
          signal.Commit4.CUSTOMER_role.c.b.m.price.result |
            b <- Bank_renamed_, m <- Agent_renamed_, c <- Agent_renamed_, 
            price <- Price_renamed_, result <- Result_renamed_, 
            order <- Order_renamed_
      ]]
      \ diff(Events, alphaAuthenticateBANKToCUSTOMERAgreement_m_price_result)

endmodule

assert AUTH4_M::AuthenticateBANKToCUSTOMERAgreement_m_price_result [T= 
       AUTH4_M::SYSTEM_4

-- ************************************************************************
-- *                 Authentication specification number 5                *
-- ************************************************************************

module AUTH5_M

  -- Spec parameterized by name of agent being authenticated

  AuthenticateMERCHANTToCUSTOMERAgreement_b_order_price_0(m) =
    signal.Running5.MERCHANT_role.m?c?b?order?price ->
    signal.Commit5.CUSTOMER_role.c.m.b.order.price -> STOP

  AlphaAuthenticateMERCHANTToCUSTOMERAgreement_b_order_price_0(m) =
    {|signal.Running5.MERCHANT_role.m.c,
      signal.Commit5.CUSTOMER_role.c.m |
         c <- inter(Agent, HONEST)|}

  -- Specs for particular agents being authenticated

  AuthenticateMERCHANTCToCUSTOMERAgreement_b_order_price =
    STOP

  AuthenticateMERCHANTMToCUSTOMERAgreement_b_order_price =
    AuthenticateMERCHANTToCUSTOMERAgreement_b_order_price_0(M)

  -- alphabet of specification

  alphaAuthenticateMERCHANTToCUSTOMERAgreement_b_order_price =
    Union({
      AlphaAuthenticateMERCHANTToCUSTOMERAgreement_b_order_price_0(C),
      AlphaAuthenticateMERCHANTToCUSTOMERAgreement_b_order_price_0(M)
    })

exports

  -- Specs for all agents being authenticated

  AuthenticateMERCHANTToCUSTOMERAgreement_b_order_price =
    (AuthenticateMERCHANTCToCUSTOMERAgreement_b_order_price
    [| inter(AlphaAuthenticateMERCHANTToCUSTOMERAgreement_b_order_price_0(C),
             AlphaAuthenticateMERCHANTToCUSTOMERAgreement_b_order_price_0(M)) |]
    AuthenticateMERCHANTMToCUSTOMERAgreement_b_order_price)

  -- System for authentication checking

  SYSTEM_5 =
    let Agent_renamed_ = ALGEBRA_M::applyRenamingToSet(Agent)
        Bank_renamed_ = ALGEBRA_M::applyRenamingToSet(Bank)
        Order_renamed_ = ALGEBRA_M::applyRenamingToSet(Order)
        Price_renamed_ = ALGEBRA_M::applyRenamingToSet(Price)
        Result_renamed_ = ALGEBRA_M::applyRenamingToSet(Result)
    within
      SYSTEM
       [[send.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, bsig>, <b, order, price, result>)) <-
          signal.Running5.MERCHANT_role.m.c.b.order.price,  
        receive.m.c.ALGEBRA_M::rmb((Msg4, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>, <b, price, result, order>)) <-
          signal.Commit5.CUSTOMER_role.c.m.b.order.price |
            m <- Agent_renamed_, c <- Agent_renamed_, b <- Bank_renamed_, 
            order <- Order_renamed_, price <- Price_renamed_, 
            result <- Result_renamed_, b_X_ <- Bank_renamed_, 
            price_X_ <- Price_renamed_, order_X_ <- Order_renamed_, 
            bsig <- ALGEBRA_M::applyRenamingToSet(addGarbage_({Encrypt.(BSK__.(b), <c, result>) | b <- Bank, c <- Agent, result <- Result}))
      ]]
      \ diff(Events, alphaAuthenticateMERCHANTToCUSTOMERAgreement_b_order_price)

endmodule

assert AUTH5_M::AuthenticateMERCHANTToCUSTOMERAgreement_b_order_price [T= 
       AUTH5_M::SYSTEM_5

-- ************************************************************************
-- *                 Authentication specification number 6                *
-- ************************************************************************

module AUTH6_M

  -- Spec parameterized by name of agent being authenticated

  AuthenticateMERCHANTToBANKAgreement_c_price_0(m) =
    signal.Running6.MERCHANT_role.m?b?c?price ->
    signal.Commit6.BANK_role.b.m.c.price -> STOP

  AlphaAuthenticateMERCHANTToBANKAgreement_c_price_0(m) =
    {|signal.Running6.MERCHANT_role.m.b,
      signal.Commit6.BANK_role.b.m |
         b <- inter(Bank, HONEST)|}

  -- Specs for particular agents being authenticated

  AuthenticateMERCHANTCToBANKAgreement_c_price =
    STOP

  AuthenticateMERCHANTMToBANKAgreement_c_price =
    AuthenticateMERCHANTToBANKAgreement_c_price_0(M)

  -- alphabet of specification

  alphaAuthenticateMERCHANTToBANKAgreement_c_price =
    Union({
      AlphaAuthenticateMERCHANTToBANKAgreement_c_price_0(C),
      AlphaAuthenticateMERCHANTToBANKAgreement_c_price_0(M)
    })

exports

  -- Specs for all agents being authenticated

  AuthenticateMERCHANTToBANKAgreement_c_price =
    (AuthenticateMERCHANTCToBANKAgreement_c_price
    [| inter(AlphaAuthenticateMERCHANTToBANKAgreement_c_price_0(C),
             AlphaAuthenticateMERCHANTToBANKAgreement_c_price_0(M)) |]
    AuthenticateMERCHANTMToBANKAgreement_c_price)

  -- System for authentication checking

  SYSTEM_6 =
    let Agent_renamed_ = ALGEBRA_M::applyRenamingToSet(Agent)
        Bank_renamed_ = ALGEBRA_M::applyRenamingToSet(Bank)
        Price_renamed_ = ALGEBRA_M::applyRenamingToSet(Price)
        Result_renamed_ = ALGEBRA_M::applyRenamingToSet(Result)
    within
      SYSTEM
       [[send.m.b.ALGEBRA_M::rmb((Msg2, Sq.<c, price, sig>, <c, price>)) <-
          signal.Running6.MERCHANT_role.m.b.c.price,  
        send.b.m.ALGEBRA_M::rmb((Msg3, Sq.<result, Encrypt.(BSK__.(b), <c, result>)>, <c, price, result>)) <-
          signal.Commit6.BANK_role.b.m.c.price |
            m <- Agent_renamed_, b <- Bank_renamed_, c <- Agent_renamed_, 
            price <- Price_renamed_, 
            sig <- ALGEBRA_M::applyRenamingToSet(addGarbage_({Encrypt.(SK__.(c), <b, price, sn>) | b <- Bank, c <- Agent, price <- Price, sn <- SeqNo})), 
            result <- Result_renamed_
      ]]
      \ diff(Events, alphaAuthenticateMERCHANTToBANKAgreement_c_price)

endmodule

assert AUTH6_M::AuthenticateMERCHANTToBANKAgreement_c_price [T= 
       AUTH6_M::SYSTEM_6

