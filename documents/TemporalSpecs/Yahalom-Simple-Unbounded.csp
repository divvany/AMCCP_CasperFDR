-- CSP script produced using Casper version 2.0

-- -- Simplified version of Yahalom
-- #Free variables
-- a, b : Agent
-- s : Server
-- na: Nonce [NonceNA]
-- nb : Nonce [NonceNB]
-- kab : SessionKey
-- ServerKey : Agent -> ServerKeys
-- InverseKeys = (kab, kab), (ServerKey, ServerKey)
-- 
-- #Processes
-- INITIATOR(a,na) knows ServerKey(a) generates na
-- RESPONDER(b,s,nb) knows ServerKey(b) generates nb
-- SERVER(s,kab) knows ServerKey generates kab
-- 
-- #Protocol description
-- 0.    -> a : b
-- 1.  a -> b : na
-- 2.  b -> s : {a, na, nb}{ServerKey(b)}
-- 3a. s -> a : {b, kab, na, nb}{ServerKey(a)}
-- 3b. s -> b : {a, kab}{ServerKey(b)}
-- 4.  a -> b : {nb}{kab}
-- 
-- #Specification
-- 
-- -- PASS
-- if Bob receives message 4 from Alice containing Ne1 for nb, Kabs1 for kab then
--     previously Sam sends message 3b to Bob containing Kabs1 for kab, Alice for a
--     
-- -- PASS
-- if Bob receives message 4 from Alice containing Ne1 for nb, Kabs1 for kab then
--     (previously Sam sends message 3b to Bob containing Kabs1 for kab, Alice for a)
--     and (previously Sam sends message 3a to Alice containing Kabs1 for kab, Bob for b, Ne1 for nb)
-- 
-- #Actual variables
-- Alice, Bob, Mallory : Agent
-- Sam : Server
-- Kabp : SessionKey (InternalKnown)
-- Kabs1, Kabs2 : SessionKey (InternalUnknown)
-- Np : Nonce (InternalKnown)
-- Na1, Na2 : Nonce (InternalUnknown) [NonceNA]
-- Nb1, Nb2 : Nonce (InternalUnknown) [NonceNB]
-- Ne1, Ne2 : Nonce (External)
-- InverseKeys = (Kabp, Kabp), (Kabs1, Kabs1), (Kabs2, Kabs2)
-- 
-- #Inline functions
-- symbolic ServerKey
-- 
-- #System
-- RESPONDER(Bob, Sam, Ne1)
-- RESPONDER(Bob, Sam, Ne2)
-- 
-- #Intruder Information
-- Intruder = Mallory
-- IntruderKnowledge = {Alice, Bob, Mallory, Sam, Np, ServerKey(Mallory)}
-- 
-- UnboundParallel = True

-- ************************************************************************
-- *                                Types                                 *
-- ************************************************************************

-- Main datatype, representing all possible messages

datatype Encryption =
  Alice | Bob | Mallory | Sam | Kabp | Kabs1 | Kabs2 | Np | Na1 | Na2 | Nb1 | 
  Nb2 | Ne1 | Ne2 | Garbage | ServerKey__.Agent | Sq.Seq(Encryption) | 
  Encrypt.(ALL_KEYS,Seq(Encryption)) | Hash.(HashFunction, Seq(Encryption)) | 
  Xor.(Encryption, Encryption) | Sent.(Encryption, Seq(Encryption))

-- Some indirection to get around FDR parsing bugs with :: in datatype declarations


-- All keys and hashfunctions in the system

ALL_KEYS :: {Encryption}
ALL_KEYS = Union({SessionKey, ServerKeys})

ASYMMETRIC_KEYS = {k_, inverse(k_) | k_ <- ALL_KEYS, k_!=inverse(k_)}
HashFunction :: {Encryption}
HashFunction = {}

-- All atoms in the system

ATOM = {Alice, Bob, Mallory, Sam, Kabp, Kabs1, Kabs2, Np, Na1, Na2, Nb1, 
         Nb2, Ne1, Ne2, Garbage}

-- Some standard functions

channel dummyrun_
RUN(X_) = 
  let drun = dummyrun_ -> drun
  within drun[[dummyrun_ <- x_ | x_ <- X_]]

encrypt(m_,k_) = Encrypt.(k_,m_)
decrypt(Encrypt.(k1_,m_),k_) = if k_ == inverse(k1_) then m_ else <Garbage>
decrypt(_,_) = <Garbage>
decryptable(Encrypt.(k1_,m_),k_) = k_ == inverse(k1_) 
decryptable(_,_) = false
nth(ms_,n_) = if n_ == 1 then head(ms_) else nth(tail(ms_), n_ - 1)

-- add Garbage to a set that contains and encryption,
-- hash function application of Vernam encryption

addGarbage_(S_) =
  if S_=={} then {Garbage}
  else Union({S_, {Garbage | Encrypt._ <- S_}, 
             {Garbage | Hash._ <- S_},
             {Garbage | Xor._ <- S_}})

-- Definitions of user supplied functions

ServerKey(arg_1_) = ServerKey__.(arg_1_)

-- Inverses of functions

inverse(Kabp) = Kabp
inverse(Kabs1) = Kabs1
inverse(Kabs2) = Kabs2
inverse(ServerKey__.arg_) = ServerKey__.arg_

-- Types in system

Agent = {Alice, Bob, Mallory}
Server = {Sam}
SessionKey = {Kabp, Kabs1, Kabs2}
Nonce = {Np, Na1, Na2, Nb1, Nb2, Ne1, Ne2}
ServerKeys = {ServerKey(arg_1_) | arg_1_ <- Agent}


-- ************************************************************************
-- *                               Messages                               *
-- ************************************************************************

-- Message labels

datatype Labels =
  Msg1 | Msg2 | Msg3a | Msg3b | Msg4 | Env0

MSG_BODY = {ALGEBRA_M::applyRenaming(m_) | (_,m_,_,_) <- SYSTEM_M::INT_MSG_INFO}

-- Type of principals

ALL_PRINCIPALS = Union({Agent, Server})

INTRUDER = Mallory

HONEST = diff(ALL_PRINCIPALS, {INTRUDER})

-- Channel declarations

INPUT_MSG = SYSTEM_M::INPUT_MSG
OUTPUT_MSG = SYSTEM_M::OUTPUT_MSG
DIRECT_MSG = SYSTEM_M::DIRECT_MSG
ENV_MSG :: {(Labels, Encryption, <Encryption>)}
ENV_MSG = SYSTEM_M::ENV_MSG

channel receive: ALL_PRINCIPALS.ALL_PRINCIPALS.INPUT_MSG
channel send: ALL_PRINCIPALS.ALL_PRINCIPALS.OUTPUT_MSG
channel env : ALL_PRINCIPALS.ENV_MSG
channel error
channel start, close : HONEST.HONEST_ROLE

channel leak : addGarbage_(ALL_SECRETS)
-- Roles of agents

datatype ROLE = INITIATOR_role | RESPONDER_role | SERVER_role

HONEST_ROLE = ROLE

-- Secrets in the protocol

ALL_SECRETS_0 = {}
ALL_SECRETS = addGarbage_(ALGEBRA_M::applyRenamingToSet(ALL_SECRETS_0))

-- Define type of signals, and declare signal channel

datatype Signal = 
  Claim_Secret.ALL_PRINCIPALS.ALL_SECRETS.Set(ALL_PRINCIPALS)

channel signal : Signal

Fact_1 = 
  Union({
    {Garbage},
    Agent,
    Server,
    Nonce,
    SessionKey,
    ServerKeys,
    {Encrypt.(ServerKey__.(b), <a, na, nb>) |
       a <- Agent, b <- Agent, na <- Nonce, nb <- Nonce},
    {Encrypt.(ServerKey__.(a), <b, kab, na, nb>) |
       a <- Agent, b <- Agent, kab <- SessionKey, na <- Nonce, nb <- Nonce},
    {Encrypt.(ServerKey__.(b), <a, kab>) |
       a <- Agent, b <- Agent, kab <- SessionKey},
    {Encrypt.(kab, <nb>) |
       kab <- SessionKey, nb <- Nonce},
    {Sent.(na, <a, b, na>) |
       a <- Agent, b <- Agent, na <- Nonce},
    {Sent.(Encrypt.(ServerKey__.(b), <a, na, nb>), <b, s, na, a, nb>) |
       a <- Agent, b <- Agent, na <- Nonce, nb <- Nonce, s <- Server},
    {Sent.(Encrypt.(ServerKey__.(a), <b, kab, na, nb>), <s, a, na, nb, b, kab>) |
       a <- Agent, b <- Agent, kab <- SessionKey, na <- Nonce, nb <- Nonce, 
       s <- Server},
    {Sent.(Encrypt.(ServerKey__.(b), <a, kab>), <s, b, a, na, nb, kab>) |
       a <- Agent, b <- Agent, kab <- SessionKey, na <- Nonce, nb <- Nonce, 
       s <- Server},
    {Sent.(Encrypt.(kab, <nb>), <a, b, na, kab, nb>) |
       a <- Agent, b <- Agent, kab <- SessionKey, na <- Nonce, nb <- Nonce},
    { sm_ | (sm_,_) <- INTRUDER_M::All_External_and_Internal_Deductions}
  })

external relational_inverse_image
external relational_image
transparent chase
transparent sbisim

-- ************************************************************************
-- *                            Honest Agents                             *
-- ************************************************************************

module SYSTEM_M

  -- types of messages sent and received by agents, as they are
  -- considered by those agents

  input_proj((l_,m_,se_,re_)) = (l_,m_,re_)
  rmb_input_proj((l_,m_,se_,re_)) = ALGEBRA_M::rmb((l_,m_,re_))
  output_proj((l_,m_,se_,re_)) = (l_,m_,se_)

  INPUT_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  INPUT_INT_MSG = 
    
    Union({
      INPUT_INT_MSG1,
      INPUT_INT_MSG2,
      INPUT_INT_MSG3a,
      INPUT_INT_MSG3b,
      INPUT_INT_MSG4
    })

  OUTPUT_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  OUTPUT_INT_MSG = 
    
    Union({
      OUTPUT_INT_MSG1,
      OUTPUT_INT_MSG2,
      OUTPUT_INT_MSG3a,
      OUTPUT_INT_MSG3b,
      OUTPUT_INT_MSG4
    })

  -- INITIATOR

  INITIATOR_0(a, na) =
    [] b : Agent @ member((Env0, b,<>), ENV_INT_MSG0) & 
      env_I.a.(Env0, b,<>) ->
    member((Msg1, na,<>), OUTPUT_INT_MSG1) & output.a.b.(Msg1, na,<>) ->
    [] kab : SessionKey @ [] nb : Nonce @ [] s : Server @ 
      member((Msg3a, Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>), INPUT_INT_MSG3a) & 
      input.s.a.(Msg3a, Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>) ->
    member((Msg4, Encrypt.(kab, <nb>),<>), OUTPUT_INT_MSG4) & 
    output.a.b.(Msg4, Encrypt.(kab, <nb>),<>) ->
    SKIP

  INITIATOR_1(a, na) = INITIATOR_0(a, na)

  INITIATOR(a, na) =
    INITIATOR_1(a, na)
      [[input.s.a.(l_,m_,re_) <- receive.s.a.ALGEBRA_M::rmb((l_,m_,re_)) |
          s <- Server, (l_,m_,se_,re_) <- INT_MSG_INFO3a]]
      [[output.a.b.(l_,m_,se_) <- send.a.b.ALGEBRA_M::rmb((l_,m_,se_)) |
          b <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO1]]
      [[output.a.b.(l_,m_,se_) <- send.a.b.ALGEBRA_M::rmb((l_,m_,se_)) |
          b <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO4]]
      [[env_I.a.m_ <- env.a.ALGEBRA_M::rmb(m_) |
          m_ <- ENV_INT_MSG0]]

  -- RESPONDER

  RESPONDER_0(b, s, nb) =
    [] a : Agent @ [] na : Nonce @ 
      member((Msg1, na,<>), INPUT_INT_MSG1) & input.a.b.(Msg1, na,<>) ->
    member((Msg2, Encrypt.(ServerKey__.(b), <a, na, nb>),<>), OUTPUT_INT_MSG2) & 
    output.b.s.(Msg2, Encrypt.(ServerKey__.(b), <a, na, nb>),<>) ->
    [] kab : SessionKey @ 
      member((Msg3b, Encrypt.(ServerKey__.(b), <a, kab>),<>), INPUT_INT_MSG3b) & 
      input.s.b.(Msg3b, Encrypt.(ServerKey__.(b), <a, kab>),<>) ->
    input.a.b.(Msg4, Encrypt.(inverse(kab), <nb>),<>) ->
    SKIP

  RESPONDER_1(b, s, nb) = RESPONDER_0(b, s, nb)

  RESPONDER(b, s, nb) =
    RESPONDER_1(b, s, nb)
      [[input.a.b.(l_,m_,re_) <- receive.a.b.ALGEBRA_M::rmb((l_,m_,re_)) |
          a <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO1]]
      [[input.s.b.(l_,m_,re_) <- receive.s.b.ALGEBRA_M::rmb((l_,m_,re_)) |
          s <- Server, (l_,m_,se_,re_) <- INT_MSG_INFO3b]]
      [[input.a.b.(l_,m_,re_) <- receive.a.b.ALGEBRA_M::rmb((l_,m_,re_)) |
          a <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO4]]
      [[output.b.s.(l_,m_,se_) <- send.b.s.ALGEBRA_M::rmb((l_,m_,se_)) |
          s <- Server, (l_,m_,se_,re_) <- INT_MSG_INFO2]]

  -- SERVER

  SERVER_0(s, kab) =
    [] a : Agent @ [] b : Agent @ [] na : Nonce @ [] nb : Nonce @ 
      member((Msg2, Encrypt.(ServerKey__.(b), <a, na, nb>),<>), INPUT_INT_MSG2) & 
      input.b.s.(Msg2, Encrypt.(ServerKey__.(b), <a, na, nb>),<>) ->
    member((Msg3a, Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>), OUTPUT_INT_MSG3a) & 
    output.s.a.(Msg3a, Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>) ->
    member((Msg3b, Encrypt.(ServerKey__.(b), <a, kab>),<>), OUTPUT_INT_MSG3b) & 
    output.s.b.(Msg3b, Encrypt.(ServerKey__.(b), <a, kab>),<>) ->
    SKIP

  SERVER_1(s, kab) = SERVER_0(s, kab)

  SERVER(s, kab) =
    SERVER_1(s, kab)
      [[input.b.s.(l_,m_,re_) <- receive.b.s.ALGEBRA_M::rmb((l_,m_,re_)) |
          b <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO2]]
      [[output.s.a.(l_,m_,se_) <- send.s.a.ALGEBRA_M::rmb((l_,m_,se_)) |
          a <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO3a]]
      [[output.s.b.(l_,m_,se_) <- send.s.b.ALGEBRA_M::rmb((l_,m_,se_)) |
          b <- Agent, (l_,m_,se_,re_) <- INT_MSG_INFO3b]]

  -- Process representing Alice

  Alpha_Alice = 
    Union({
      {|env.Alice|},
      {|send.Alice.A_ | A_ <- ALL_PRINCIPALS|}
    })

  AGENT_Alice = STOP

  -- Process representing Bob

  Alpha_RESPONDER_Bob = 
    Union({
      {|send.Bob.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG2|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG1|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG3b|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG4|}
    })

  RESPONDER_Bob = ((RESPONDER(Bob, Sam, Ne1) ; STOP)
    |||
    (RESPONDER(Bob, Sam, Ne2) ; STOP))

  Alpha_Bob = 
    Union({
      {|env.Bob|},
      {|send.Bob.A_ | A_ <- ALL_PRINCIPALS|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG1|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG3b|},
      {|receive.A_.Bob.m_ | A_ <- ALL_PRINCIPALS, m_ <- INPUT_MSG4|}
    })

  AGENT_Bob =
    (RESPONDER_Bob [Alpha_RESPONDER_Bob || {} ] STOP)

  -- Process representing Sam

  Alpha_Sam = 
    Union({
      {|env.Sam|},
      {|send.Sam.A_ | A_ <- ALL_PRINCIPALS|}
    })

  AGENT_Sam = STOP

exports

  -- Messages as they appear on the network; each messages is renamed
  -- (by rmb) to the representative member of its equivalence class

  INPUT_MSG1 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG1}
  INPUT_MSG2 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG2}
  INPUT_MSG3a = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG3a}
  INPUT_MSG3b = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG3b}
  INPUT_MSG4 = {ALGEBRA_M::rmb(m_) | m_ <- INPUT_INT_MSG4}

  OUTPUT_MSG1 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG1}
  OUTPUT_MSG2 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG2}
  OUTPUT_MSG3a = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG3a}
  OUTPUT_MSG3b = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG3b}
  OUTPUT_MSG4 = {ALGEBRA_M::rmb(m_) | m_ <- OUTPUT_INT_MSG4}

  DIRECT_MSG1 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO1}
  DIRECT_MSG2 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO2}
  DIRECT_MSG3a = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO3a}
  DIRECT_MSG3b = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO3b}
  DIRECT_MSG4 = {ALGEBRA_M::rmb4(m_) | m_ <- INT_MSG_INFO4}

  -- Environmental messages

  ENV_INT_MSG0 :: {(Labels, Encryption, <Encryption>)}
  ENV_INT_MSG0 = 
    {(Env0, b, <>) |
       b <- Agent}

  ENV_MSG0 = {ALGEBRA_M::rmb(m_) | m_ <- ENV_INT_MSG0}

  ENV_INT_MSG :: {(Labels, Encryption, <Encryption>)}
  ENV_INT_MSG = ENV_INT_MSG0

  -- information about messages sent and received by agents, including
  -- extras fields for both agents

  INT_MSG_INFO1_0 = 
    {(Msg1, na, <>, <>) |
       na <- Nonce}
  INT_MSG_INFO1 = 
    {(Msg1, m, s, r) | (Msg1,m,s,r) <- INT_MSG_INFO1_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO2_0 = 
    {(Msg2, Encrypt.(ServerKey__.(b), <a, na, nb>), <>, <>) |
       a <- Agent, b <- Agent, na <- Nonce, nb <- Nonce}
  INT_MSG_INFO2 = 
    {(Msg2, m, s, r) | (Msg2,m,s,r) <- INT_MSG_INFO2_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO3a_0 = 
    {(Msg3a, Encrypt.(ServerKey__.(a), <b, kab, na, nb>), <>, <>) |
       a <- Agent, b <- Agent, kab <- SessionKey, na <- Nonce, nb <- Nonce}
  INT_MSG_INFO3a = 
    {(Msg3a, m, s, r) | (Msg3a,m,s,r) <- INT_MSG_INFO3a_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO3b_0 = 
    {(Msg3b, Encrypt.(ServerKey__.(b), <a, kab>), <>, <>) |
       a <- Agent, b <- Agent, kab <- SessionKey}
  INT_MSG_INFO3b = 
    {(Msg3b, m, s, r) | (Msg3b,m,s,r) <- INT_MSG_INFO3b_0,
      member(m,INTRUDER_M::KnowableFact)}
  INT_MSG_INFO4_0 = 
    {(Msg4, Encrypt.(kab, <nb>), <>, <>) |
       kab <- SessionKey, nb <- Nonce}
  INT_MSG_INFO4 = 
    {(Msg4, m, s, r) | (Msg4,m,s,r) <- INT_MSG_INFO4_0,
      member(m,INTRUDER_M::KnowableFact)}

  ENV_MSG = {ALGEBRA_M::rmb(m_) | m_ <- ENV_INT_MSG}

  INT_MSG_INFO :: {(Labels, Encryption, <Encryption>, <Encryption>)}
  INT_MSG_INFO = 
    Union({
      INT_MSG_INFO1,
      INT_MSG_INFO2,
      INT_MSG_INFO3a,
      INT_MSG_INFO3b,
      INT_MSG_INFO4
    })
  INPUT_INT_MSG1 = { input_proj(mt_) | mt_ <- INT_MSG_INFO1 }
  INPUT_INT_MSG2 = { input_proj(mt_) | mt_ <- INT_MSG_INFO2 }
  INPUT_INT_MSG3a = { input_proj(mt_) | mt_ <- INT_MSG_INFO3a }
  INPUT_INT_MSG3b = { input_proj(mt_) | mt_ <- INT_MSG_INFO3b }
  INPUT_INT_MSG4 = { input_proj(mt_) | mt_ <- INT_MSG_INFO4 }

  INPUT_MSG = 
    Union({
      INPUT_MSG1,
      INPUT_MSG2,
      INPUT_MSG3a,
      INPUT_MSG3b,
      INPUT_MSG4
    })
  OUTPUT_INT_MSG1 = { output_proj(mt_) | mt_ <- INT_MSG_INFO1 }
  OUTPUT_INT_MSG2 = { output_proj(mt_) | mt_ <- INT_MSG_INFO2 }
  OUTPUT_INT_MSG3a = { output_proj(mt_) | mt_ <- INT_MSG_INFO3a }
  OUTPUT_INT_MSG3b = { output_proj(mt_) | mt_ <- INT_MSG_INFO3b }
  OUTPUT_INT_MSG4 = { output_proj(mt_) | mt_ <- INT_MSG_INFO4 }

  OUTPUT_MSG = 
    Union({
      OUTPUT_MSG1,
      OUTPUT_MSG2,
      OUTPUT_MSG3a,
      OUTPUT_MSG3b,
      OUTPUT_MSG4
    })
  DIRECT_MSG = 
  Union({
    DIRECT_MSG1,
    DIRECT_MSG2,
    DIRECT_MSG3a,
    DIRECT_MSG3b,
    DIRECT_MSG4
  })

  channel input:ALL_PRINCIPALS.ALL_PRINCIPALS.INPUT_INT_MSG
  channel output: ALL_PRINCIPALS.ALL_PRINCIPALS.OUTPUT_INT_MSG
  channel env_I : ALL_PRINCIPALS.ENV_INT_MSG

  -- Complete system

  SYSTEM_0 =
    (AGENT_Alice
      [Alpha_Alice||union(Alpha_Bob, Alpha_Sam)]
    (AGENT_Bob
      [Alpha_Bob||Alpha_Sam]
    AGENT_Sam))

endmodule

-- ************************************************************************
-- *                               Algebra                                *
-- ************************************************************************

module ALGEBRA_M

  -- Algebraic laws, defined as a set of pairs

  laws = {(Garbage, Garbage)}

  -- Calculate transitive closure of algebraic laws, and select
  -- representative member of each equivalence class

  external mtransclose
  renaming = mtransclose(laws, Fact_1)
  ren = relational_inverse_image(renaming)

  -- function that renames non-sequential fact to representative member

  applyRenaming0(a_) =
    let S_ = ren(a_)
    within if card(S_)==0 then a_ else elsing(S_)

  elsing({x_}) = x_

  domain = {a_ | (_,a_) <- renaming}

exports

  -- function that renames arbitrary fact to representative member

  applyRenaming(Sq.ms_) =
    if member(Sq.ms_, Fact_1) then applyRenaming0(Sq.ms_) 
    else Sq.<applyRenaming0(m_) | m_ <- ms_>
  applyRenaming(a_) = applyRenaming0(a_)

  -- function that renames (label, fact, extras) triples

  rmb((l_,m_,extras_)) = 
    (l_, applyRenaming(m_), applyRenamingToSeq(extras_))
  rmb4((l_,m_,s_extras_,r_extras_)) = 
    (l_, applyRenaming(m_), applyRenamingToSeq(s_extras_), 
     applyRenamingToSeq(r_extras_))

  -- lift renaming to sets and to deductions

  applyRenamingToSet(X_) =
    union({elsing(ren(a_)) | a_ <- inter(X_,domain)},  diff(X_, domain))

  applyRenamingToSeq(X_) = <applyRenaming(e_) | e_ <- X_>

  applyRenamingToDeductions(S_) =
    {(applyRenaming0(f_), applyRenamingToSet(X_)) | (f_,X_) <- S_}

endmodule

-- ************************************************************************
-- *                             The Intruder                             *
-- ************************************************************************

module INTRUDER_M

  -- Unbound Parallel functions and sets, necessary for deductions

  honest(x) = x != Mallory

  -- Intruder's deductions

  unSq_ (Sq.ms_) = set(ms_)
  unSq_ (m_) = {m_}

  unknown_(S_) = diff(S_, IK0)

  Base_Deductions_ =
    Union({SqDeductions, UnSqDeductions, 
           EncryptionDeductions, DecryptionDeductions,
           VernEncDeductions, VernDecDeductions, 
           FnAppDeductions, HashDeductions,
           SentDeductions, All_Internal_Deductions, UserDeductions})

  SqDeductions =
    {(Sq.fs_, unknown_(set(fs_))) | Sq.fs_ <- Fact_1}

  UnSqDeductions =
    {(f_, unknown_({Sq.fs_})) | Sq.fs_ <- Fact_1, f_ <- unknown_(set(fs_))}

  EncryptionDeductions =
    {(Encrypt.(k_,fs_), unknown_(union({k_}, set(fs_)))) | 
        Encrypt.(k_,fs_) <- Fact_1}

  DecryptionDeductions =
    {(f_, unknown_({Encrypt.(k_,fs_), inverse(k_)})) |
        Encrypt.(k_,fs_) <- Fact_1, f_ <- unknown_(set(fs_))}

  VernEncDeductions =
    {(Xor.(m1_,m2_), unknown_(union(unSq_(m1_), unSq_(m2_)))) | 
        Xor.(m1_,m2_) <- Fact_1}

  VernDecDeductions =
      {(m11_, union(unknown_(unSq_(m2_)), {Xor.(m1_,m2_)})) | 
         Xor.(m1_,m2_) <- Fact_1, m11_ <- unSq_(m1_)}

  HashDeductions = {(Hash.(f_, ms_), set(ms_)) | Hash.(f_, ms_) <- Fact_1}

  -- Unbound Parallel Deductions

  SentDeductions = {(m_, {Sent.(m_,fs_)}) | Sent.(m_,fs_) <- Fact_1}

  -- The paramaterised deductions

  deductions_INITIATOR_0(a, na, b, s, nb, kab) =
    Union({
      {( Sent.(na, <a, b, na>), {  })},
      {( Sent.(Encrypt.(kab, <nb>), <a, b, na, kab, nb>), 
        { Encrypt.(ServerKey__.(a), <b, kab, na, nb>), Sent.(na, <a, b, na>) })}
    })

  -- Deductions for internalised INITIATOR running with honest
  -- agent
  deductions_INITIATOR_with_honest =
    Union({
      deductions_INITIATOR_0(a, na, b, s, nb, kab) |
        b <- Agent, s <- Server, nb <- Nonce, kab <- SessionKey, a <- inter(Agent,HONEST), na <- {Na1, Na2}, honest(b) and honest(s)
      })

  -- Deductions for internalised INITIATOR running with dishonest
  -- agent.
  deductions_INITIATOR_with_dishonest =
    Union({
      deductions_INITIATOR_0(a, na, b, s, nb, kab) |
        b <- Agent, s <- Server, nb <- Nonce, kab <- SessionKey, a <- inter(Agent,HONEST), na <- {Np}, not(honest(b) and honest(s))
      })

  -- Deductions for external INITIATOR running with any agent
  -- These are used to better approximate KnowableFact so as to reduce the
  -- size of LearnableFact.
  deductions_INITIATOR_external_0(a, na, b, s, nb, kab) =
    Union({
      {( na, {  })},
      {( Encrypt.(kab, <nb>), 
        { Encrypt.(ServerKey__.(a), <b, kab, na, nb>), na })}
    })

  deductions_INITIATOR_external = 
    Union({
      deductions_INITIATOR_external_0(a, na, b, s, nb, kab) | 
        b <- Agent, s <- Server, nb <- Nonce, kab <- SessionKey, a <- {}, na <- {Ne1, Ne2}
    })

  -- The paramaterised deductions

  deductions_RESPONDER_0(a, na, b, s, nb, kab) =
    {( Sent.(Encrypt.(ServerKey__.(b), <a, na, nb>), <b, s, na, a, nb>), 
        { na })}

  -- Deductions for internalised RESPONDER running with honest
  -- agent
  deductions_RESPONDER_with_honest =
    Union({
      deductions_RESPONDER_0(a, na, b, s, nb, kab) |
        a <- Agent, na <- Nonce, kab <- SessionKey, b <- inter(Agent,HONEST), s <- Server, nb <- {Nb1, Nb2}, honest(a)
      })

  -- Deductions for internalised RESPONDER running with dishonest
  -- agent.
  deductions_RESPONDER_with_dishonest =
    Union({
      deductions_RESPONDER_0(a, na, b, s, nb, kab) |
        a <- Agent, na <- Nonce, kab <- SessionKey, b <- inter(Agent,HONEST), s <- Server, nb <- {Np}, not(honest(a))
      })

  -- Deductions for external RESPONDER running with any agent
  -- These are used to better approximate KnowableFact so as to reduce the
  -- size of LearnableFact.
  deductions_RESPONDER_external_0(a, na, b, s, nb, kab) =
    {( Encrypt.(ServerKey__.(b), <a, na, nb>), { na })}

  deductions_RESPONDER_external = 
    Union({
      deductions_RESPONDER_external_0(a, na, b, s, nb, kab) | 
        a <- Agent, na <- Nonce, kab <- SessionKey, b <- {Bob}, s <- Server, nb <- {Ne1, Ne2}
    })

  -- The paramaterised deductions

  deductions_SERVER_0(a, na, b, s, nb, kab) =
    Union({
      {( Sent.(Encrypt.(ServerKey__.(a), <b, kab, na, nb>), <s, a, na, nb, b, kab>), 
        { Encrypt.(ServerKey__.(b), <a, na, nb>) })},
      {( Sent.(Encrypt.(ServerKey__.(b), <a, kab>), <s, b, a, na, nb, kab>), 
        { Sent.(Encrypt.(ServerKey__.(a), <b, kab, na, nb>), <s, a, na, nb, b, kab>) })}
    })

  -- Deductions for internalised SERVER running with honest
  -- agent
  deductions_SERVER_with_honest =
    Union({
      deductions_SERVER_0(a, na, b, s, nb, kab) |
        a <- Agent, na <- Nonce, b <- Agent, nb <- Nonce, s <- inter(Server,HONEST), kab <- {Kabs1, Kabs2}, honest(a) and honest(b)
      })

  -- Deductions for internalised SERVER running with dishonest
  -- agent.
  deductions_SERVER_with_dishonest =
    Union({
      deductions_SERVER_0(a, na, b, s, nb, kab) |
        a <- Agent, na <- Nonce, b <- Agent, nb <- Nonce, s <- inter(Server,HONEST), kab <- {Kabp}, not(honest(a) and honest(b))
      })

  -- Deductions for external SERVER running with any agent
  -- These are used to better approximate KnowableFact so as to reduce the
  -- size of LearnableFact.
  deductions_SERVER_external_0(a, na, b, s, nb, kab) =
    Union({
      {( Encrypt.(ServerKey__.(a), <b, kab, na, nb>), 
        { Encrypt.(ServerKey__.(b), <a, na, nb>) })},
      {( Encrypt.(ServerKey__.(b), <a, kab>), 
        { Encrypt.(ServerKey__.(a), <b, kab, na, nb>) })}
    })

  deductions_SERVER_external = 
    Union({
      deductions_SERVER_external_0(a, na, b, s, nb, kab) | 
        a <- Agent, na <- Nonce, b <- Agent, nb <- Nonce, s <- {}, kab <- {}
    })

  All_Internal_Deductions = 
    Union({
      deductions_INITIATOR_with_honest,
      deductions_RESPONDER_with_honest,
      deductions_SERVER_with_honest,
      deductions_INITIATOR_with_dishonest,
      deductions_RESPONDER_with_dishonest,
      deductions_SERVER_with_dishonest
    })

  All_External_and_Internal_Deductions_ = 
    Union({
      All_Internal_Deductions,
      deductions_INITIATOR_external,
      deductions_RESPONDER_external,
      deductions_SERVER_external
    })

  All_Deductions = Union({Base_Deductions, All_External_and_Internal_Deductions})

  UserDeductions = {}

  FnAppDeductions = {}

  -- close up intruder's initial knowledge under deductions;
  -- calculate which facts cannot be learnt

  components_(Sq.ms_) = 
    if member(Sq.ms_, Fact_1) then {Sq.ms_} else set(ms_)
  components_(m_) = {m_}

  Seeable_ = 
    Union({unknown_(components_(m_)) | (_,m_,_,_) <- SYSTEM_M::INT_MSG_INFO})

  -- The intruder

  -- * leak is used to signal that a possible secret has been learnt
  -- * hear and say are used to represent hearing or saying a message
  -- * infer(f,fs) represent deducing fact f from the set of facts fs

  -- Component of intruder for currently unknown fact f_:
  -- * ms_ is the set of messages that contain f_ at the top level
  -- * fss_ is the set of sets of facts from which f_ can be deduced
  -- * ds_ is the set of deductions that use f_

  IGNORANT(f_,ms_,fss_,ds_) =
    hear?m_:ms_ -> KNOWS(f_,ms_,ds_)
    []
    ([] fs_ : fss_, not(member(f_,fs_)) @ 
        infer.(f_,fs_) -> KNOWS(f_,ms_,ds_))

  -- Component of intruder for known fact f_

  KNOWS(f_,ms_,ds_) =
    hear?m_:ms_ -> KNOWS(f_,ms_,ds_)
    []
    say?m_:ms_ -> KNOWS(f_,ms_,ds_)
    [] 
    ([] ded@@(f1_,fs_) : ds_, f1_!=f_ @ infer.ded -> KNOWS(f_,ms_,ds_))
    []
    member(f_,ALL_SECRETS) & leak.f_ -> KNOWS(f_,ms_,ds_)

  -- Alphabet of this component

  AlphaL(f_,ms_,fss_,ds_) =
    Union({(if member(f_,ALL_SECRETS) then {leak.f_} else {}),
           {hear.m_, say.m_ | m_ <- ms_},
           {infer.(f_,fs_) | fs_ <- fss_},
           {infer.(f1_,fs_) | (f1_,fs_) <- ds_}
         })

  -- Set of all (f_, ms_, fss_, ds_) for which intruder components 
  -- must be built

  f_ms_fss_ds_s(Deductions,LearnableFact) = 
    let rid_ = relational_image(Deductions)
        msf_ = relational_image({(f_, m_) | m_ <- MSG_BODY, f_ <- unSq_(m_)})
        xsf_ = relational_image({(f_, x_) | x_@@(_,fs_) <- Deductions,
                                            f_ <- fs_})
    within {(f_, msf_(f_), rid_(f_), xsf_(f_)) | f_ <- LearnableFact}

  -- Rename events appropriately

  BUILD_INTRUDER_0(INTRUDER_0) =
    ((chase(INTRUDER_0)
      [[ hear.m_ <- hear.m_, hear.m_ <- send.A_.B_.(l_,m_,se_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2,
           SYSTEM_M::DIRECT_MSG3a,
           SYSTEM_M::DIRECT_MSG3b,
           SYSTEM_M::DIRECT_MSG4
         }), 
         A_ <- diff(SenderType(l_),{Mallory}), 
         B_ <- ReceiverType(l_) ]] 
     [|{| hear |}|] STOP)
      [[ say.m_ <- receive.A_.B_.(l_,m_,re_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2,
           SYSTEM_M::DIRECT_MSG3a,
           SYSTEM_M::DIRECT_MSG3b,
           SYSTEM_M::DIRECT_MSG4
         }), 
         A_ <- SenderType(l_), 
         B_ <- ReceiverType(l_) ]] 
     [|{| say |}|] STOP)

  -- Add in facts that are known initially

  SAY_KNOWN_0(IK1) = 
    (inter(IK1, ALL_SECRETS) != {} & dummy_leak -> SAY_KNOWN_0(IK1)) 
    [] dummy_send -> SAY_KNOWN_0(IK1) 
    [] dummy_receive -> SAY_KNOWN_0(IK1) 

  SAY_KNOWN(IK1) =
    SAY_KNOWN_0(IK1)
      [[ dummy_leak <- leak.f_ | f_ <- inter(IK1, ALL_SECRETS) ]]
      [[ dummy_send <- dummy_send, dummy_send <- send.A_.B_.(l_,m_,se_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2,
           SYSTEM_M::DIRECT_MSG3a,
           SYSTEM_M::DIRECT_MSG3b,
           SYSTEM_M::DIRECT_MSG4
         }), components_(m_) <= IK1, 
         A_ <- diff(SenderType(l_),{Mallory}), 
         B_ <- ReceiverType(l_) ]] 
      [[ dummy_receive <- dummy_receive, dummy_receive <- receive.A_.B_.(l_,m_,re_) | 
         (l_,m_,se_,re_) <- Union({
           SYSTEM_M::DIRECT_MSG1,
           SYSTEM_M::DIRECT_MSG2,
           SYSTEM_M::DIRECT_MSG3a,
           SYSTEM_M::DIRECT_MSG3b,
           SYSTEM_M::DIRECT_MSG4
         }), components_(m_) <= IK1, 
         A_ <- SenderType(l_), 
         B_ <- ReceiverType(l_) ]] 

  STOP_SET = { dummy_send, dummy_receive }

exports

  -- Types of sender and receiver of each message

  SenderType (Msg1) = Agent
  SenderType (Msg2) = Agent
  SenderType (Msg3a) = Server
  SenderType (Msg3b) = Server
  SenderType (Msg4) = Agent

  ReceiverType(Msg1) = Agent
  ReceiverType(Msg2) = Server
  ReceiverType(Msg3a) = Agent
  ReceiverType(Msg3b) = Agent
  ReceiverType(Msg4) = Agent

  -- Intruder's initial knowledge

  IK0 = {Alice, Bob, Mallory, Sam, Np, ServerKey__.(Mallory), Garbage}

  Base_Deductions = Base_Deductions_

  All_External_and_Internal_Deductions =  All_External_and_Internal_Deductions_

  Close_(IK_, ded_, fact_) =
    CloseButNotFacts_(IK_, ded_, fact_, { })

  -- The method below is used to calculate IK1 and Deductions and is important
  -- when authentication checks are being done. If no check was done on f being
  -- in Facts then the infer event corresponding to a signal may be hidden.
  CloseButNotFacts_(IK_, ded_, fact_, signal_facts_) =
    let IK1_ = 
          union(IK_, {f_ | (f_,fs_) <- ded_, fs_ <= IK_ and not member(f_, signal_facts_)})
        ded1_ = 
          {(f_,fs_) | (f_,fs_) <- ded_, not (member(f_,IK_)),
                      fs_ <= fact_}
    within
    if card(IK_)==card(IK1_) and card(ded_)==card(ded1_)
    then (IK_, {(f_,diff(fs_,IK_)) | (f_,fs_) <- ded_})
    else CloseButNotFacts_(IK1_, ded1_, fact_, signal_facts_)

  -- Calculate knowable facts based using the external and internal deductions
  (KnowableFact_, _) = 
    Close_(ALGEBRA_M::applyRenamingToSet(IK0), 
           ALGEBRA_M::applyRenamingToDeductions(All_Deductions), 
           ALGEBRA_M::applyRenamingToSet(Fact_1))

KnowableFact = KnowableFact_ 
  -- Put components together in parallel
  INTRUDER_00(Deductions,LearnableFact) = 
    (|| (f_,ms_,fss_,ds_) : f_ms_fss_ds_s(Deductions,LearnableFact) @ 
         [AlphaL(f_,ms_,fss_,ds_)] IGNORANT(f_,ms_,fss_,ds_))

  -- Set of all deductions that could occur
  COMBINED_DEDUCTIONS =
    let ds_ = 
        Union({
          TEMPORAL_SPEC_1_M::Deductions,
          TEMPORAL_SPEC_2_M::Deductions
        })
    within -- Don't you hate hacks like this (FDR does not allow empty channel types)?
      if ds_ == {} then {(Garbage, {Garbage})} else ds_

  -- Declare channels:
  channel hear, say : MSG_BODY
  channel dummy_leak, dummy_send, dummy_receive

  -- Complete intruder

  -- Intruder used for temporal specs
  BUILD_INTRUDER'(INTRUDER_0,IK) =
    (BUILD_INTRUDER_0(INTRUDER_0) ||| SAY_KNOWN(IK)) [| STOP_SET |] STOP

endmodule

-- FDR bug: cannot have a module prefix in a channel type
Deductions' = INTRUDER_M::COMBINED_DEDUCTIONS
channel infer : Deductions'

IntruderInterface = 
  Union({
    {| receive.Mallory.A_.m_ | A_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| receive.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- Union({
      SYSTEM_M::INPUT_MSG1,
      SYSTEM_M::INPUT_MSG2,
      SYSTEM_M::INPUT_MSG3a,
      SYSTEM_M::INPUT_MSG3b,
      SYSTEM_M::INPUT_MSG4
    }) |},
    {| send.A_.Mallory.m_ | A_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- {} |},
    {| send.A_.B_.m_ | A_ <- ALL_PRINCIPALS, B_ <- ALL_PRINCIPALS, m_ <- Union({
      SYSTEM_M::OUTPUT_MSG1,
      SYSTEM_M::OUTPUT_MSG2,
      SYSTEM_M::OUTPUT_MSG3a,
      SYSTEM_M::OUTPUT_MSG3b,
      SYSTEM_M::OUTPUT_MSG4
    }) |}
  })

-- ************************************************************************
-- *                    Specifications and Assertions                     *
-- ************************************************************************

-- ************************************************************************
-- *                       Temporal Specifications                        *
-- ************************************************************************

module TEMPORAL_SPEC_COMMON_M
exports
  -- System to be used for checking temporal specifications
  SYSTEM(Renaming,AlphaSpec) =
    let
      FactsExcludedFromClosure = {f_ | (f_, _) <- Renaming}

      -- Close up the intruder's initial knowledge not including any facts
      -- that later get renamed in Renaming.
      (IK, Deductions) =
        INTRUDER_M::CloseButNotFacts_(
          ALGEBRA_M::applyRenamingToSet(INTRUDER_M::IK0),
          ALGEBRA_M::applyRenamingToDeductions(INTRUDER_M::Base_Deductions),
          ALGEBRA_M::applyRenamingToSet(INTRUDER_M::KnowableFact),
          FactsExcludedFromClosure)

      LearnableFact = diff(INTRUDER_M::KnowableFact, IK)

      -- Rename all infers as specififed by renaming
      INTRUDER_0 = 
        INTRUDER_M::INTRUDER_00(Deductions,LearnableFact)
          [[infer.ded_ <- b_ | (f_,b_) <- Renaming, (f_',fs_) @@ ded_ <- Deductions, f_' == f_]]
          \ {| infer |}
    within
      ((SYSTEM_M::SYSTEM_0 [| IntruderInterface |] INTRUDER_M::BUILD_INTRUDER'(INTRUDER_0,IK))
      [[internalAgentSend.a_.b_.m_ <- send.a_.b_.m_
        | a_ <- ALL_PRINCIPALS, b_ <- ALL_PRINCIPALS, m_ <- OUTPUT_MSG
      ]]
      \ diff(Events, AlphaSpec), Deductions)
endmodule

-- Channel definitions
channel internalAgentSend : ALL_PRINCIPALS.ALL_PRINCIPALS.OUTPUT_MSG

-- ************************************************************************
-- *                        Temporal Logic Spec 1                         *
-- ************************************************************************

module TEMPORAL_SPEC_1_M
  -- The set of all events that we are interested in
  AlphaSpec = 
    Union({
      { receive.a.b.(Msg4,Encrypt.(inverse(kab), <nb>),<>)
         | a <- {Alice}, b <- {Bob}, kab <- {Kabs1}, nb <- {Ne1}, 
           member((Msg4,Encrypt.(inverse(kab), <nb>),<>),SYSTEM_M::INPUT_INT_MSG4)},
      { send.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>)
         | a <- {Alice}, b <- {Bob}, kab <- {Kabs1}, s <- {Sam}, 
           member((Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>),SYSTEM_M::OUTPUT_INT_MSG3b)}
    })

  -- The set of events that can occur in any state of the automata
  RunEvents = 
    { send.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>)
         | a <- {Alice}, b <- {Bob}, kab <- {Kabs1}, s <- {Sam}, 
           member((Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>),SYSTEM_M::OUTPUT_INT_MSG3b)}

exports

  -- The automata
  SPEC =
    let
      STATE_0() =
        ([] e : RunEvents @ e -> STATE_0())
        [] ([] s : {Sam} @ [] b : {Bob} @ [] a : {Alice} @ [] kab : {Kabs1} @ 
          member((Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>),SYSTEM_M::OUTPUT_INT_MSG3b) & 
          send.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>) -> STATE_1())
      STATE_1() =
        ([] e : RunEvents @ e -> STATE_1())
        [] ([] a : {Alice} @ [] b : {Bob} @ [] kab : {Kabs1} @ [] nb : {Ne1} @ 
          member((Msg4,Encrypt.(inverse(kab), <nb>),<>),SYSTEM_M::INPUT_INT_MSG4) & 
          receive.a.b.(Msg4,Encrypt.(inverse(kab), <nb>),<>) -> STATE_1())
    within
      STATE_0()

  -- Set of pairs (ded,rn) such that infer.ded is renamed to rn
  Renaming =
    {(f_, internalAgentSend.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>))
        | Sent.(Encrypt.(ServerKey__.(b), <a, kab>), <s, b_0_, a_0_, na, nb, kab_0_>) @@ f_ <- INTRUDER_M::KnowableFact,
          kab_0_ == kab, a_0_ == a, b_0_ == b, member(a,{Alice}), member(b,{Bob}), member(kab,{Kabs1}), member(s,{Sam})
      }

  -- The system for testing this specification
  (SYSTEM_SPEC, Deductions) = 
    TEMPORAL_SPEC_COMMON_M::SYSTEM(Renaming, AlphaSpec)

endmodule

assert TEMPORAL_SPEC_1_M::SPEC [T= TEMPORAL_SPEC_1_M::SYSTEM_SPEC

-- ************************************************************************
-- *                        Temporal Logic Spec 2                         *
-- ************************************************************************

module TEMPORAL_SPEC_2_M
  -- The set of all events that we are interested in
  AlphaSpec = 
    Union({
      { receive.a.b.(Msg4,Encrypt.(inverse(kab), <nb>),<>)
         | a <- {Alice}, b <- {Bob}, kab <- {Kabs1}, nb <- {Ne1}, 
           member((Msg4,Encrypt.(inverse(kab), <nb>),<>),SYSTEM_M::INPUT_INT_MSG4)},
      { send.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>)
         | a <- {Alice}, b <- {Bob}, kab <- {Kabs1}, s <- {Sam}, 
           member((Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>),SYSTEM_M::OUTPUT_INT_MSG3b)},
      { send.s.a.(Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>)
         | a <- {Alice}, b <- {Bob}, kab <- {Kabs1}, na <- Nonce, nb <- {Ne1}, s <- {Sam}, 
           member((Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>),SYSTEM_M::OUTPUT_INT_MSG3a)}
    })

  -- The set of events that can occur in any state of the automata
  RunEvents = 
    Union({
      { send.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>)
         | a <- {Alice}, b <- {Bob}, kab <- {Kabs1}, s <- {Sam}, 
           member((Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>),SYSTEM_M::OUTPUT_INT_MSG3b)},
      { send.s.a.(Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>)
         | a <- {Alice}, b <- {Bob}, kab <- {Kabs1}, na <- Nonce, nb <- {Ne1}, s <- {Sam}, 
           member((Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>),SYSTEM_M::OUTPUT_INT_MSG3a)}
    })

exports

  -- The automata
  SPEC =
    let
      STATE_0() =
        ([] e : RunEvents @ e -> STATE_0())
        [] ([] s : {Sam} @ [] b : {Bob} @ [] a : {Alice} @ [] kab : {Kabs1} @ 
          member((Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>),SYSTEM_M::OUTPUT_INT_MSG3b) & 
          send.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>) -> STATE_1())
        [] ([] s : {Sam} @ [] a : {Alice} @ [] b : {Bob} @ [] kab : {Kabs1} @ [] na : Nonce @ [] nb : {Ne1} @ 
          member((Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>),SYSTEM_M::OUTPUT_INT_MSG3a) & 
          send.s.a.(Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>) -> STATE_2())
      STATE_1() =
        ([] e : RunEvents @ e -> STATE_1())
        [] ([] s : {Sam} @ [] a : {Alice} @ [] b : {Bob} @ [] kab : {Kabs1} @ [] na : Nonce @ [] nb : {Ne1} @ 
          member((Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>),SYSTEM_M::OUTPUT_INT_MSG3a) & 
          send.s.a.(Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>) -> STATE_3())
      STATE_2() =
        ([] e : RunEvents @ e -> STATE_2())
        [] ([] s : {Sam} @ [] b : {Bob} @ [] a : {Alice} @ [] kab : {Kabs1} @ 
          member((Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>),SYSTEM_M::OUTPUT_INT_MSG3b) & 
          send.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>) -> STATE_3())
      STATE_3() =
        ([] e : RunEvents @ e -> STATE_3())
        [] ([] a : {Alice} @ [] b : {Bob} @ [] kab : {Kabs1} @ [] nb : {Ne1} @ 
          member((Msg4,Encrypt.(inverse(kab), <nb>),<>),SYSTEM_M::INPUT_INT_MSG4) & 
          receive.a.b.(Msg4,Encrypt.(inverse(kab), <nb>),<>) -> STATE_3())
    within
      STATE_0()

  -- Set of pairs (ded,rn) such that infer.ded is renamed to rn
  Renaming =
    Union({
      {(f_, internalAgentSend.s.b.(Msg3b,Encrypt.(ServerKey__.(b), <a, kab>),<>))
        | Sent.(Encrypt.(ServerKey__.(b), <a, kab>), <s, b_0_, a_0_, na, nb, kab_0_>) @@ f_ <- INTRUDER_M::KnowableFact,
          kab_0_ == kab, a_0_ == a, b_0_ == b, member(a,{Alice}), member(b,{Bob}), member(kab,{Kabs1}), member(s,{Sam})
      },
      {(f_, internalAgentSend.s.a.(Msg3a,Encrypt.(ServerKey__.(a), <b, kab, na, nb>),<>))
        | Sent.(Encrypt.(ServerKey__.(a), <b, kab, na, nb>), <s, a_0_, na_0_, nb_0_, b_0_, kab_0_>) @@ f_ <- INTRUDER_M::KnowableFact,
          kab_0_ == kab, b_0_ == b, nb_0_ == nb, na_0_ == na, a_0_ == a, member(a,{Alice}), member(b,{Bob}), member(kab,{Kabs1}), member(nb,{Ne1}), member(s,{Sam})
      }
    })

  -- The system for testing this specification
  (SYSTEM_SPEC, Deductions) = 
    TEMPORAL_SPEC_COMMON_M::SYSTEM(Renaming, AlphaSpec)

endmodule

assert TEMPORAL_SPEC_2_M::SPEC [T= TEMPORAL_SPEC_2_M::SYSTEM_SPEC

